================================================
FILE: aiken.lock
================================================
# This file was generated by Aiken
# You typically do not need to edit this file

[[requirements]]
name = "aiken-lang/fuzz"
version = "v2.1.1"
source = "github"

[[packages]]
name = "aiken-lang/fuzz"
version = "v2.1.1"
requirements = []
source = "github"

[etags]



================================================
FILE: aiken.toml
================================================
name = "aiken-lang/stdlib"
version = "main"
compiler = "v1.1.19"
plutus = "v3"
description = "The Aiken Standard Library"

[repository]
user = "aiken-lang"
project = "stdlib"
platform = "github"

[[dependencies]]
name = "aiken-lang/fuzz"
version = "v2.1.1"
source = "github"



================================================
FILE: lib/aiken/cbor.ak
================================================
use aiken
use aiken/builtin.{decode_utf8, serialise_data}
use aiken/primitive/bytearray

/// Obtain a String representation of _anything_. This is particularly (and only) useful for tracing
/// and debugging. This function is expensive and should not be used in any production code as it
/// will very likely explodes the validator's budget.
///
/// The output is a [CBOR diagnostic](https://www.rfc-editor.org/rfc/rfc8949#name-diagnostic-notation)
/// of the underlying on-chain binary representation of the data. It's not as
/// easy to read as plain Aiken code, but it is handy for troubleshooting values
/// _at runtime_. Incidentally, getting familiar with reading CBOR diagnostic is
/// a good idea in the Cardano world.
///
/// ```aiken
/// cbor.diagnostic(42) == "42"
/// cbor.diagnostic(#"a1b2") == "h'A1B2'"
/// cbor.diagnostic([1, 2, 3]) == "[_ 1, 2, 3]"
/// cbor.diagnostic([]) == "[]"
/// cbor.diagnostic((1, 2)) == "[_ 1, 2]"
/// cbor.diagnostic((1, #"ff", 3)) == "[_ 1, h'FF', 3]"
/// cbor.diagnostic([(1, #"ff")]) == "{_ 1: h'FF' }"
/// cbor.diagnostic(Some(42)) == "121([_ 42])"
/// cbor.diagnostic(None) == "122([])"
/// ```
pub fn diagnostic(self: Data) -> String {
  aiken.diagnostic(self, #"")
    |> decode_utf8
}

/// Deserialise a [CBOR](https://www.rfc-editor.org/rfc/rfc8949) Data. This is the reverse operation of [serialise](#serialise).
/// In particular, we have the following property:
///
/// ```aiken
/// cbor.deserialise(cbor.serialise(any_data)) == Some(any_data)
/// ```
///
/// > [!CAUTION]
/// > Unfortunately, this function isn't derived from a builtin primitive. It
/// > is therefore an order of magnitude more expensive than its counterpart
/// > and shall be used with care.
/// >
/// > In general, one might prefer avoiding deserialisation unless truly necessary.
/// > Yet, it may come in handy for testing and in rare scenarios.
pub fn deserialise(bytes: ByteArray) -> Option<Data> {
  let length = bytearray.length(bytes)

  let peek =
    fn(offset: Int, callback: fn(Byte) -> Decoder<Data>) -> Decoder<Data> {
      fn(cursor) {
        if 0 >= cursor {
          deserialise_failure
        } else {
          callback(bytearray.at(bytes, length - cursor))(cursor - offset)
        }
      }
    }

  let take =
    fn(n: Int, callback: fn(ByteArray) -> Decoder<Data>) -> Decoder<Data> {
      fn(cursor) {
        if 0 >= cursor {
          deserialise_failure
        } else {
          callback(builtin.slice_bytearray(length - cursor, n, bytes))(
            cursor - n,
          )
        }
      }
    }

  if length == 0 {
    None
  } else {
    let Pair(result, consumed) = decode_data(peek, take)(length)
    if consumed != 0 {
      None
    } else {
      Some(result)
    }
  }
}

/// Serialise any value to binary, encoding using [CBOR](https://www.rfc-editor.org/rfc/rfc8949).
///
/// This is particularly useful in combination with hashing functions, as a way
/// to obtain a byte representation that matches the serialised representation
/// used by the ledger in the context of on-chain code.
///
/// Note that the output matches the output of [`diagnostic`](#diagnostic),
/// though with a different encoding. [`diagnostic`](#diagnostic) is merely a
/// textual representation of the CBOR encoding that is human friendly and
/// useful for debugging.
///
/// ```aiken
/// cbor.serialise(42) == #"182a"
/// cbor.serialise(#"a1b2") == #"42a1b2"
/// cbor.serialise([]) == #"80"
/// cbor.serialise((1, 2)) == #"9f0102ff"
/// cbor.serialise((1, #"ff", 3)) == #"9f0141ff03ff"
/// cbor.serialise([(1, #"ff")]) == #"a10141ff"
/// cbor.serialise(Some(42)) == #"d8799f182aff"
/// cbor.serialise(None) == #"d87a80"
/// ```
pub fn serialise(self: Data) -> ByteArray {
  serialise_data(self)
}

type Byte =
  Int

type Decoder<a> =
  fn(Int) -> Pair<a, Int>

type Peek<a> =
  fn(Int, fn(Byte) -> Decoder<a>) -> Decoder<a>

type Take<a> =
  fn(Int, fn(ByteArray) -> Decoder<a>) -> Decoder<a>

fn return(data: Data) -> Decoder<Data> {
  fn(cursor) { Pair(data, cursor) }
}

const deserialise_failure: Pair<Data, Int> = {
    let empty: Data = ""
    Pair(empty, -1)
  }

const token_begin_bytes = 0x5f

const token_begin_list = 0x9f

const token_begin_map = 0xbf

const token_break = 0xff

fn decode_data(peek: Peek<Data>, take: Take<Data>) -> Decoder<Data> {
  let next <- peek(1)
  let major_type = next / 32
  if major_type <= 2 {
    if major_type == 0 {
      let i <- decode_uint(peek, take, next)
      return(builtin.i_data(i))
    } else if major_type == 1 {
      let i <- decode_uint(peek, take, next - 32)
      return(builtin.i_data(-i - 1))
    } else {
      if next == token_begin_bytes {
        let b <- decode_chunks(peek, take)
        return(builtin.b_data(b))
      } else {
        let b <- decode_bytes(peek, take, next - 64)
        return(builtin.b_data(b))
      }
    }
  } else if major_type == 6 {
    let tag <- decode_uint(peek, take, next - 192)
    let next <- peek(1)
    if tag == 102 {
      fn(_) { deserialise_failure }
    } else {
      let ix =
        if tag >= 1280 {
          tag - 1280 + 7
        } else {
          tag - 121
        }
      if next == token_begin_list {
        let fields <- decode_indefinite(peek, take, decode_data)
        return(builtin.constr_data(ix, fields))
      } else {
        let size <- decode_uint(peek, take, next - 128)
        let fields <- decode_definite(peek, take, decode_data, size)
        return(builtin.constr_data(ix, fields))
      }
    }
  } else if major_type == 4 {
    if next == token_begin_list {
      let xs <- decode_indefinite(peek, take, decode_data)
      return(builtin.list_data(xs))
    } else {
      let size <- decode_uint(peek, take, next - 128)
      let xs <- decode_definite(peek, take, decode_data, size)
      return(builtin.list_data(xs))
    }
  } else if major_type == 5 {
    if next == token_begin_map {
      let xs <- decode_indefinite(peek, take, decode_pair)
      return(builtin.map_data(xs))
    } else {
      let size <- decode_uint(peek, take, next - 160)
      let xs <- decode_definite(peek, take, decode_pair, size)
      return(builtin.map_data(xs))
    }
  } else {
    fn(_) { deserialise_failure }
  }
}

fn decode_pair(peek: Peek<Data>, take: Take<Data>) -> Decoder<Pair<Data, Data>> {
  fn(cursor) {
    let Pair(k, cursor) = decode_data(peek, take)(cursor)
    let Pair(v, cursor) = decode_data(peek, take)(cursor)
    Pair(Pair(k, v), cursor)
  }
}

fn decode_uint(
  peek: Peek<Data>,
  take: Take<Data>,
  header: Int,
  and_then: fn(Int) -> Decoder<Data>,
) -> Decoder<Data> {
  if header < 24 {
    and_then(header)
  } else if header == 24 {
    let payload <- peek(1)
    and_then(payload)
  } else if header < 28 {
    let width = bytearray.at(#[2, 4, 8], header - 25)
    let payload <- take(width)
    and_then(bytearray.to_int_big_endian(payload))
  } else {
    fn(_) { deserialise_failure }
  }
}

fn decode_bytes(
  peek: Peek<Data>,
  take: Take<Data>,
  header: Int,
  and_then: fn(ByteArray) -> Decoder<Data>,
) -> Decoder<Data> {
  let width <- decode_uint(peek, take, header)
  let bytes <- take(width)
  and_then(bytes)
}

fn decode_chunks(
  peek: Peek<Data>,
  take: Take<Data>,
  and_then: fn(ByteArray) -> Decoder<Data>,
) -> Decoder<Data> {
  let next <- peek(1)
  if next == token_break {
    and_then("")
  } else {
    let chunk <- decode_bytes(peek, take, next - 64)
    let chunks <- decode_chunks(peek, take)
    and_then(builtin.append_bytearray(chunk, chunks))
  }
}

fn decode_definite(
  peek: Peek<Data>,
  take: Take<Data>,
  decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>,
  size: Int,
  and_then: fn(List<a>) -> Decoder<Data>,
) -> Decoder<Data> {
  if size <= 0 {
    and_then([])
  } else {
    fn(cursor) {
      let Pair(elem, cursor) = decode_one(peek, take)(cursor)
      {
        let elems <- decode_definite(peek, take, decode_one, size - 1)
        and_then([elem, ..elems])
      }(cursor)
    }
  }
}

fn decode_indefinite(
  peek: Peek<Data>,
  take: Take<Data>,
  decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>,
  and_then: fn(List<a>) -> Decoder<Data>,
) -> Decoder<Data> {
  let next <- peek(1)
  if next == token_break {
    and_then([])
  } else {
    fn(cursor) {
      let Pair(elem, cursor) = decode_one(peek, take)(cursor + 1)
      {
        let elems <- decode_indefinite(peek, take, decode_one)
        and_then([elem, ..elems])
      }(cursor)
    }
  }
}



================================================
FILE: lib/aiken/collection.ak
================================================
/// A non negative integer that materializes the position of an element in a
/// collection.
pub type Index =
  Int



================================================
FILE: lib/aiken/crypto.ak
================================================
use aiken/builtin

pub type VerificationKey =
  ByteArray

pub type VerificationKeyHash =
  Hash<Blake2b_224, VerificationKey>

pub type Script =
  ByteArray

pub type ScriptHash =
  Hash<Blake2b_224, Script>

pub type Signature =
  ByteArray

pub type DataHash =
  Hash<Blake2b_256, Data>

/// A `Hash` is nothing more than a `ByteArray`, but it carries extra
/// information for readability.
///
/// On-chain, any hash digest value is represented as a plain 'ByteArray'.
/// Though in practice, hashes come from different sources and have
/// different semantics.
///
/// Hence, while this type-alias doesn't provide any strong type-guarantees,
/// it helps writing functions signatures with more meaningful types than mere
/// 'ByteArray'.
///
/// Compare for example:
///
/// ```aiken
/// pub type Credential {
///   VerificationKey(ByteArray)
///   Script(ByteArray)
/// }
/// ```
///
/// with
///
/// ```aiken
/// pub type Credential {
///   VerificationKey(Hash<Blake2b_224, VerificationKey>)
///   Script(Hash<Blake2b_224, Script>)
/// }
/// ```
///
/// Both are strictly equivalent, but the second reads much better.
pub type Hash<alg, a> =
  ByteArray

// ## Hashing

/// A blake2b-224 hash algorithm.
///
/// Typically used for:
///
/// - [`Credential`](../cardano/address.html#Credential)
/// - [`PolicyId`](../cardano/assets.html#PolicyId)
pub opaque type Blake2b_224 {
  Blake2b_224
}

/// Compute the blake2b-224 hash digest (28 bytes) of some data.
/// Minimum Plutus Version: 3
pub fn blake2b_224(bytes: ByteArray) -> Hash<Blake2b_224, a> {
  builtin.blake2b_224(bytes)
}

/// A blake2b-256 hash algorithm.
///
/// Typically used for:
///
/// - [`TransactionId`](../cardano/transaction.html#TransactionId)
pub opaque type Blake2b_256 {
  Blake2b_256
}

/// Compute the blake2b-256 hash digest (32 bytes) of some data.
pub fn blake2b_256(bytes: ByteArray) -> Hash<Blake2b_256, a> {
  builtin.blake2b_256(bytes)
}

/// A Keccak-256 hash algorithm.
pub opaque type Keccak_256 {
  Keccak_256
}

/// Compute the keccak-256 hash digest (32 bytes) of some data.
pub fn keccak_256(bytes: ByteArray) -> Hash<Keccak_256, a> {
  builtin.keccak_256(bytes)
}

/// A SHA2-256 hash algorithm.
pub opaque type Sha2_256 {
  Sha2_256
}

/// Compute the sha2-256 hash digest (32 bytes) of some data.
pub fn sha2_256(bytes: ByteArray) -> Hash<Sha2_256, a> {
  builtin.sha2_256(bytes)
}

/// A SHA3-256 hash algorithm.
pub opaque type Sha3_256 {
  Sha3_256
}

/// Compute the sha3-256 hash digest (32 bytes) of some data.
pub fn sha3_256(bytes: ByteArray) -> Hash<Sha3_256, a> {
  builtin.sha3_256(bytes)
}

// ## Verifying signatures

/// Verify an ECDCA signature (over secp256k1) using the given verification key.
/// Returns `True` when the signature is valid.
pub fn verify_ecdsa_signature(
  key: VerificationKey,
  msg: ByteArray,
  sig: Signature,
) -> Bool {
  builtin.verify_ecdsa_secp256k1_signature(key, msg, sig)
}

/// Verify an Ed25519 signature using the given verification key.
/// Returns `True` when the signature is valid.
pub fn verify_ed25519_signature(
  key: VerificationKey,
  msg: ByteArray,
  sig: Signature,
) -> Bool {
  builtin.verify_ed25519_signature(key, msg, sig)
}

/// Verify a Schnorr signature (over secp256k1) using the given verification key.
/// Returns `True` when the signature is valid.
pub fn verify_schnorr_signature(
  key: VerificationKey,
  msg: ByteArray,
  sig: Signature,
) -> Bool {
  builtin.verify_schnorr_secp256k1_signature(key, msg, sig)
}



================================================
FILE: lib/aiken/interval.ak
================================================
//// In a eUTxO-based blockchain like Cardano, the management of time can be
//// finicky.
////
//// Indeed, in order to maintain a complete determinism in the execution of
//// scripts, it is impossible to introduce a notion of _"current time"_ since
//// the execution would then depend on factor that are external to the
//// transaction itself: the ineluctable stream of time flowing in our universe.
////
//// Hence, to work around that, we typically define time intervals, which gives
//// window -- a.k.a intervals -- within which the transaction can be executed.
//// From within a script, it isn't possible to know when exactly the script is
//// executed, but we can reason about the interval bounds to validate pieces of
//// logic.
////
//// ## Example
////
//// Let's consider an example and assume an auction with a bidding period over
//// an interval $biddingPeriod = [start_{bid}, end_{bid})$.
////
//// - Bidders for the auction must be whitelisted by an administrator before the
//// bidding period starts.
////
//// - Once the bidding period is over, the auction winner may collect its due by
//// paying the agreed price.
////
//// This scenario identifies three periods:
////
//// ```
////    pre-bidding            bidding            post-bidding
//// -----------------[-----------------------)----------------->
////              start_bid                end_bid
//// ```
////
//// If we call $validityRange = [start_{tx}, end_{tx})$ the validity interval
//// of transactions during each period, we must then have:
////
//// > [!TIP]
//// > In Plutus V3, transaction validity ranges are always semi-open intervals, open in their upper bound.
////
//// 1. Pre-bidding: $end_{tx} \lt start_{bid}$
////
////    ```aiken
////    validity_range |> interval.is_entirely_before(start_bid)
////    ```
////
//// 2. Bidding: $validityRange \subseteq biddingPeriod$
////
////    ```aiken
////    bidding_period |> interval.includes(validity_range)
////    ```
////
////    or alternatively $start_{tx} \geq start_{bid}$ and $end_{tx} \lt end_{bid}$:
////
////    ```aiken
////    and {
////      bidding_period |> interval.contains(start_tx),
////      bidding_period |> interval.contains(end_tx),
////    }
////    ```
////
//// 3. Post-bidding: $start_{tx} \gt end_{bid}$
////
////    ```aiken
////    validity_range |> interval.is_entirely_after(end_bid)
////    ```

use aiken/primitive/int
use aiken/primitive/string

// By convention, infinites are inclusive
const positive_infinity: IntervalBound =
  IntervalBound { bound_type: PositiveInfinity, is_inclusive: True }

// By convention, infinites are inclusive
const negative_infinity: IntervalBound =
  IntervalBound { bound_type: NegativeInfinity, is_inclusive: True }

///
/// A type to represent intervals of values. Interval are inhabited by an
/// integer value representing  have a finite lower-bound and/or upper-bound.
///
/// This allows to represent all kind of mathematical intervals:
///
/// ```aiken
/// // [1; 10]
/// let i0: Interval = Interval
///   { lower_bound:
///       IntervalBound { bound_type: Finite(1), is_inclusive: True }
///   , upper_bound:
///       IntervalBound { bound_type: Finite(10), is_inclusive: True }
///   }
/// ```
///
/// ```aiken
/// // (20; infinity)
/// let i1: Interval = Interval
///   { lower_bound:
///       IntervalBound { bound_type: Finite(20), is_inclusive: False }
///   , upper_bound:
///       IntervalBound { bound_type: PositiveInfinity, is_inclusive: False }
///   }
/// ```
pub type Interval {
  lower_bound: IntervalBound,
  upper_bound: IntervalBound,
}

/// An interval bound, either inclusive or exclusive.
pub type IntervalBound {
  bound_type: IntervalBoundType,
  is_inclusive: Bool,
}

/// A type of interval bound. The value for the `Finite` case typically
/// represents a number of seconds or milliseconds.
pub type IntervalBoundType {
  NegativeInfinity
  Finite(Int)
  PositiveInfinity
}

// ## Constructing

/// Create an interval that includes all values greater than the given bound. i.e $[lower_bound, +âˆž]$
///
/// ```aiken
/// interval.after(10) == Interval {
///   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },
///   upper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },
/// }
/// ```
pub fn after(lower_bound: Int) -> Interval {
  Interval {
    lower_bound: IntervalBound {
      bound_type: Finite(lower_bound),
      is_inclusive: True,
    },
    upper_bound: positive_infinity,
  }
}

/// Create an interval that includes all values after (and not including) the given bound. i.e $(lower_bound, +âˆž]$
///
/// ```aiken
/// interval.entirely_after(10) == Interval {
///   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },
///   upper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },
/// }
/// ```
pub fn entirely_after(lower_bound: Int) -> Interval {
  Interval {
    lower_bound: IntervalBound {
      bound_type: Finite(lower_bound),
      is_inclusive: False,
    },
    upper_bound: positive_infinity,
  }
}

/// Create an interval that includes all values before (and including) the given bound. i.e $(-âˆž, upper_bound]$
///
/// ```aiken
/// interval.before(100) == Interval {
///   lower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },
///   upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },
/// }
/// ```
pub fn before(upper_bound: Int) -> Interval {
  Interval {
    lower_bound: negative_infinity,
    upper_bound: IntervalBound {
      bound_type: Finite(upper_bound),
      is_inclusive: True,
    },
  }
}

/// Create an interval that includes all values before (and not including) the given bound. i.e $(-âˆž, upper_bound)$
///
/// ```aiken
/// interval.entirely_before(10) == Interval {
///   lower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },
///   upper_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },
/// }
/// ```
pub fn entirely_before(upper_bound: Int) -> Interval {
  Interval {
    lower_bound: negative_infinity,
    upper_bound: IntervalBound {
      bound_type: Finite(upper_bound),
      is_inclusive: False,
    },
  }
}

/// Create an interval that includes all values between two bounds, including the bounds. i.e. $[lower_bound, upper_bound]$
///
/// ```aiken
/// interval.between(10, 100) == Interval {
///   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },
///   upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },
/// }
/// ```
pub fn between(lower_bound: Int, upper_bound: Int) -> Interval {
  Interval {
    lower_bound: IntervalBound {
      bound_type: Finite(lower_bound),
      is_inclusive: True,
    },
    upper_bound: IntervalBound {
      bound_type: Finite(upper_bound),
      is_inclusive: True,
    },
  }
}

/// Create an interval that includes all values between two bounds, excluding the bounds. i.e. $(lower_bound, upper_bound)$
///
/// ```aiken
/// interval.entirely_between(10, 100) == Interval {
///   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },
///   upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },
/// }
/// ```
pub fn entirely_between(lower_bound: Int, upper_bound: Int) -> Interval {
  Interval {
    lower_bound: IntervalBound {
      bound_type: Finite(lower_bound),
      is_inclusive: False,
    },
    upper_bound: IntervalBound {
      bound_type: Finite(upper_bound),
      is_inclusive: False,
    },
  }
}

/// Create an empty interval that contains no value.
///
/// ```aiken
/// interval.contains(empty, 0) == False
/// interval.contains(empty, 1000) == False
/// ```
pub const empty: Interval =
  Interval { lower_bound: positive_infinity, upper_bound: negative_infinity }

/// Create an interval that contains every possible values. i.e. $(-âˆž, +âˆž)$
///
/// ```aiken
/// interval.contains(everything, 0) == True
/// interval.contains(everything, 1000) == True
/// ```
pub const everything: Interval =
  Interval { lower_bound: negative_infinity, upper_bound: positive_infinity }

// ## Inspecting

/// Checks whether an element is contained within the interval.
///
/// ```aiken
/// let iv =
///   Interval {
///     lower_bound: IntervalBound {
///       bound_type: Finite(14),
///       is_inclusive: True
///     },
///     upper_bound: IntervalBound {
///       bound_type: Finite(42),
///       is_inclusive: False
///     },
///   }
///
/// interval.contains(iv, 25) == True
/// interval.contains(iv, 0) == False
/// interval.contains(iv, 14) == True
/// interval.contains(iv, 42) == False
/// ```
pub fn contains(self: Interval, elem: Int) -> Bool {
  let is_greater_than_lower_bound =
    when self.lower_bound.bound_type is {
      NegativeInfinity -> True
      Finite(lower_bound) ->
        if self.lower_bound.is_inclusive {
          elem >= lower_bound
        } else {
          elem > lower_bound
        }
      PositiveInfinity -> False
    }

  let is_smaller_than_upper_bound =
    when self.upper_bound.bound_type is {
      NegativeInfinity -> False
      Finite(upper_bound) ->
        if self.upper_bound.is_inclusive {
          elem <= upper_bound
        } else {
          elem < upper_bound
        }
      PositiveInfinity -> True
    }

  is_greater_than_lower_bound && is_smaller_than_upper_bound
}

test contains_1() {
  let iv = everything
  contains(iv, 14)
}

test contains_2() {
  let iv = entirely_before(15)
  contains(iv, 14)
}

test contains_3() {
  let iv = before(14)
  contains(iv, 14)
}

test contains_4() {
  let iv = entirely_before(14)
  !contains(iv, 14)
}

test contains_5() {
  let iv = entirely_after(13)
  contains(iv, 14)
}

test contains_6() {
  let iv = after(14)
  contains(iv, 14)
}

test contains_7() {
  let iv = entirely_after(14)
  !contains(iv, 14)
}

test contains_8() {
  let iv = between(42, 1337)
  !contains(iv, 14)
}

test contains_9() {
  let iv = between(0, 42)
  contains(iv, 14)
}

test contains_10() {
  let iv = between(0, 42)
  contains(iv, 42)
}

test contains_11() {
  let iv = entirely_between(0, 42)
  !contains(iv, 0)
}

test contains_12() {
  let iv = empty
  !contains(iv, 14)
}

/// Tells whether an interval is empty; i.e. that is contains no value.
///
/// ```aiken
/// let iv1 = interval.empty
///
/// let iv2 = Interval {
///     lower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },
///     upper_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },
///   }
///
/// let iv3 = Interval {
///     lower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },
///     upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },
///   }
///
/// interval.is_empty(iv1) == True
/// interval.is_empty(iv2) == True
/// interval.is_empty(iv3) == False
///
/// // Note: Two empty intervals are not necessarily equal.
/// iv1 != iv2
/// ```
pub fn is_empty(Interval { lower_bound, upper_bound }: Interval) -> Bool {
  when lower_bound.bound_type is {
    NegativeInfinity -> False
    PositiveInfinity -> upper_bound.bound_type != PositiveInfinity
    Finite(l) ->
      when upper_bound.bound_type is {
        NegativeInfinity -> True
        Finite(r) -> {
          let l =
            if lower_bound.is_inclusive {
              l
            } else {
              l + 1
            }
          if upper_bound.is_inclusive {
            l > r
          } else {
            l >= r
          }
        }
        PositiveInfinity -> False
      }
  }
}

/// Check whether the interval is entirely after a given point.
///
/// ```aiken
/// interval.is_entirely_after(interval.after(10), 5) == True
/// interval.is_entirely_after(interval.after(10), 10) == False
/// interval.is_entirely_after(interval.after(10), 15) == False
/// interval.is_entirely_after(interval.between(10, 20), 30) == False
/// interval.is_entirely_after(interval.between(10, 20), 5) == True
/// ```
pub fn is_entirely_after(self: Interval, point: Int) -> Bool {
  when self.lower_bound.bound_type is {
    Finite(low) ->
      if self.lower_bound.is_inclusive {
        point < low
      } else {
        point <= low
      }
    NegativeInfinity -> False
    PositiveInfinity -> True
  }
}

test is_entirely_after_1() {
  is_entirely_after(after(10), 5)
}

test is_entirely_after_2() {
  !is_entirely_after(after(10), 10)
}

test is_entirely_after_3() {
  !is_entirely_after(after(10), 15)
}

test is_entirely_after_4() {
  !is_entirely_after(between(10, 20), 30)
}

test is_entirely_after_5() {
  is_entirely_after(between(10, 20), 5)
}

test is_entirely_after_6() {
  is_entirely_after(entirely_after(10), 10)
}

test is_entirely_after_7() {
  !is_entirely_after(before(10), 5)
}

test is_entirely_after_8() {
  !is_entirely_after(before(10), 15)
}

test is_entirely_after_9() {
  !is_entirely_after(entirely_before(10), 5)
}

test is_entirely_after_10() {
  is_entirely_after(
    Interval {
      lower_bound: IntervalBound {
        bound_type: PositiveInfinity,
        is_inclusive: True,
      },
      upper_bound: IntervalBound {
        bound_type: PositiveInfinity,
        is_inclusive: False,
      },
    },
    1,
  )
}

/// Check whether the interval is entirely before a given point.
///
/// ```aiken
/// interval.is_entirely_before(interval.before(10), 15) == True
/// interval.is_entirely_before(interval.before(10), 10) == False
/// interval.is_entirely_before(interval.before(10), 5) == False
/// interval.is_entirely_before(interval.between(10, 20), 30) == True
/// interval.is_entirely_before(interval.between(10, 20), 5) == False
/// ```
pub fn is_entirely_before(self: Interval, point: Int) -> Bool {
  when self.upper_bound.bound_type is {
    Finite(hi) ->
      if self.upper_bound.is_inclusive {
        hi < point
      } else {
        hi <= point
      }
    PositiveInfinity -> False
    NegativeInfinity -> True
  }
}

test is_entirely_before_1() {
  is_entirely_before(before(10), 15)
}

test is_entirely_before_2() {
  !is_entirely_before(before(10), 10)
}

test is_entirely_before_3() {
  !is_entirely_before(before(10), 5)
}

test is_entirely_before_4() {
  is_entirely_before(between(10, 20), 30)
}

test is_entirely_before_5() {
  !is_entirely_before(between(10, 20), 5)
}

test is_entirely_before_6() {
  is_entirely_before(entirely_before(10), 10)
}

test is_entirely_before_7() {
  !is_entirely_before(after(10), 15)
}

test is_entirely_before_8() {
  !is_entirely_before(after(10), 5)
}

test is_entirely_before_9() {
  !is_entirely_before(entirely_after(10), 5)
}

test is_entirely_before_10() {
  is_entirely_before(
    Interval {
      lower_bound: IntervalBound {
        bound_type: NegativeInfinity,
        is_inclusive: True,
      },
      upper_bound: IntervalBound {
        bound_type: NegativeInfinity,
        is_inclusive: False,
      },
    },
    1,
  )
}

/// Obtain a human-readable string representation of the interval. Useful for debugging.
pub fn to_string(self: Interval) -> String {
  let lower_bracket =
    if self.lower_bound.is_inclusive {
      @"["
    } else {
      @"("
    }

  let lower_bound = bound_type_to_string(self.lower_bound.bound_type)

  let upper_bound = bound_type_to_string(self.upper_bound.bound_type)

  let upper_bracket =
    if self.upper_bound.is_inclusive {
      @"]"
    } else {
      @")"
    }

  lower_bracket
    |> string.concat(lower_bound)
    |> string.concat(@", ")
    |> string.concat(upper_bound)
    |> string.concat(upper_bracket)
}

fn bound_type_to_string(self: IntervalBoundType) -> String {
  when self is {
    NegativeInfinity -> @"-âˆž"
    Finite(i) -> string.from_int(i)
    PositiveInfinity -> @"+âˆž"
  }
}

// ## Combining

/// Computes the smallest interval containing the two given intervals, if any
///
/// ```aiken
/// let iv1 = between(0, 10) // [0, 10]
/// let iv2 = between(2, 14) // [2, 14]
/// hull(iv1, iv2) == between(0, 14)
///
/// let iv1 = between(5, 10) // [5, 10]
/// let iv2 = before(0) // [Ù’-âˆž, 0]
/// hull(iv1, iv2) == before(10)
///
/// let iv1 = entirely_after(0) // (0, +âˆž]
/// let iv2 = between(10, 42)  // [10, 42]
/// hull(iv1, iv2) = entirely_after(0)
/// ```
pub fn hull(iv1: Interval, iv2: Interval) -> Interval {
  Interval {
    lower_bound: min(iv1.lower_bound, iv2.lower_bound, inclusive_lower_bound),
    upper_bound: max(iv1.upper_bound, iv2.upper_bound, inclusive_upper_bound),
  }
}

test hull_1() {
  let iv1 = between(0, 10)
  let iv2 = between(2, 14)
  hull(iv1, iv2) == between(0, 14)
}

test hull_2() {
  let iv1 = between(5, 10)
  let iv2 = before(0)
  hull(iv1, iv2) == before(10)
}

test hull_3() {
  let iv1 = entirely_after(0)
  let iv2 = between(10, 42)
  hull(iv1, iv2) == entirely_after(0)
}

/// Checks whether the second interval is fully included in the first.
///
/// ```aiken
/// between(-5, 5)  // [-5, 5]
///   |> includes(between(0, 2)) // [0, 2]
///
/// between(-5, 5)  // [-5, 5]
///   |> includes(entirely_between(-5, 5)) // (-5, 5)
///
/// after(0) // [0, +âˆž]
///   |> includes(after(1)) // [1, +âˆž]
///
/// before(-1) // (-âˆž, -1]
///   |> includes(entirely_before(-1)) // [-âˆž, -1)
/// ```
pub fn includes(self: Interval, other: Interval) -> Bool {
  if is_empty(other) {
    True
  } else if is_empty(self) {
    False
  } else {
    and {
      compare_bound(self.lower_bound, other.lower_bound, inclusive_lower_bound) != Greater,
      compare_bound(self.upper_bound, other.upper_bound, inclusive_upper_bound) != Less,
    }
  }
}

// contains :: (Enum a, Ord a) => Interval a -> Interval a -> Bool
// -- Everything contains the empty interval
// contains _ i2 | isEmpty i2 = True
// -- Nothing is contained in the empty interval (except the empty interval,
// -- which is already handled)
// contains i1 _ | isEmpty i1 = False
// -- Otherwise we check the endpoints. This doesn't work for empty intervals,
// -- hence the cases above.
// contains (Interval l1 h1) (Interval l2 h2) = l1 <= l2 && h2 <= h1
// {-# INLINABLE contains #-}

test includes_1() {
  between(-5, 5) |> includes(between(-5, 5))
}

test includes_2() {
  between(-5, 5) |> includes(between(0, 2))
}

test includes_3() {
  between(-5, 5) |> includes(entirely_between(-5, 5))
}

test includes_4() {
  !(entirely_between(-5, 5) |> includes(between(-5, 5)))
}

test includes_5() {
  and {
    after(0) |> includes(after(1)),
    entirely_after(0) |> includes(entirely_after(1)),
  }
}

test includes_6() {
  and {
    after(0) |> includes(after(1)),
    entirely_after(0) |> includes(after(1)),
  }
}

test includes_7() {
  and {
    before(0) |> includes(before(-1)),
    entirely_before(0) |> includes(before(-1)),
  }
}

test includes_8() {
  and {
    !(before(-1) |> includes(before(0))),
    !(entirely_before(-1) |> includes(before(0))),
  }
}

/// Computes the largest interval contained in the two given intervals, if any.
///
/// ```aiken
/// let iv1 = interval.between(0, 10) // [0, 10]
/// let iv2 = interval.between(2, 14) // [2, 14]
/// interval.intersection(iv1, iv2) == interval.between(2, 10)
///
/// let iv1 = interval.entirely_before(10) // [-âˆž, 10)
/// let iv2 = interval.entirely_after(0) // (0, +âˆž]
/// interval.intersection(iv1, iv2) == interval.entirely_between(0, 10)
///
/// let iv1 = interval.between(0, 1) // [0, 1]
/// let iv2 = interval.between(2, 3) // [2, 3]
/// interval.intersection(iv1, iv2) |> interval.is_empty
/// ```
pub fn intersection(iv1: Interval, iv2: Interval) -> Interval {
  Interval {
    lower_bound: max(iv1.lower_bound, iv2.lower_bound, inclusive_lower_bound),
    upper_bound: min(iv1.upper_bound, iv2.upper_bound, inclusive_upper_bound),
  }
}

test intersection_1() {
  let iv1 = between(0, 10)
  let iv2 = between(2, 14)
  intersection(iv1, iv2) == between(2, 10)
}

test intersection_2() {
  let iv1 = between(0, 1)
  let iv2 = between(1, 2)
  intersection(iv1, iv2) == between(1, 1)
}

test intersection_3() {
  let iv1 = between(0, 1)
  let iv2 = entirely_between(1, 2)
  intersection(iv1, iv2)
    |> is_empty
}

test intersection_4() {
  let iv1 = entirely_between(0, 1)
  let iv2 = entirely_between(1, 2)
  intersection(iv1, iv2)
    |> is_empty
}

test intersection_5() {
  let iv1 = between(0, 10)
  let iv2 = before(4)
  intersection(iv1, iv2) == between(0, 4)
}

test intersection_6() {
  let iv1 = entirely_before(10)
  let iv2 = entirely_after(0)
  intersection(iv1, iv2) == entirely_between(0, 10)
}

/// Return the highest bound of the two. For equal `IntervalBoundType`,
/// an inclusive `IntervalBound` is considered higher.
///
/// ```aiken
/// let ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }
/// let ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }
///
/// interval.max(ib1, ib2) == ib2
/// ```
fn max(
  left: IntervalBound,
  right: IntervalBound,
  to_inclusive: fn(IntervalBound) -> IntervalBoundType,
) -> IntervalBound {
  let ord = compare_bound_type(to_inclusive(left), to_inclusive(right))
  when ord is {
    Greater | Equal -> left
    Less -> right
  }
}

/// Return the smallest bound of the two. For equal `IntervalBoundType`,
/// an inclusive `IntervalBound` is considered smaller.
///
/// ```aiken
/// let ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }
/// let ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }
///
/// interval.min(ib1, ib2) == ib1
/// ```
fn min(
  left: IntervalBound,
  right: IntervalBound,
  to_inclusive: fn(IntervalBound) -> IntervalBoundType,
) -> IntervalBound {
  let ord = compare_bound_type(to_inclusive(left), to_inclusive(right))
  when ord is {
    Less | Equal -> left
    Greater -> right
  }
}

fn compare_bound(
  left: IntervalBound,
  right: IntervalBound,
  to_inclusive: fn(IntervalBound) -> IntervalBoundType,
) -> Ordering {
  compare_bound_type(to_inclusive(left), to_inclusive(right))
}

fn compare_bound_type(
  left: IntervalBoundType,
  right: IntervalBoundType,
) -> Ordering {
  when left is {
    NegativeInfinity ->
      when right is {
        NegativeInfinity -> Equal
        _ -> Less
      }
    PositiveInfinity ->
      when right is {
        PositiveInfinity -> Equal
        _ -> Greater
      }
    Finite(l) ->
      when right is {
        NegativeInfinity -> Greater
        Finite(r) -> int.compare(l, r)
        PositiveInfinity -> Less
      }
  }
}

fn inclusive_lower_bound(
  IntervalBound { bound_type, is_inclusive }: IntervalBound,
) -> IntervalBoundType {
  if is_inclusive {
    bound_type
  } else {
    when bound_type is {
      Finite(x) -> Finite(x + 1)
      NegativeInfinity | PositiveInfinity -> bound_type
    }
  }
}

fn inclusive_upper_bound(
  IntervalBound { bound_type, is_inclusive }: IntervalBound,
) -> IntervalBoundType {
  if is_inclusive {
    bound_type
  } else {
    when bound_type is {
      Finite(x) -> Finite(x - 1)
      NegativeInfinity | PositiveInfinity -> bound_type
    }
  }
}



================================================
FILE: lib/aiken/math.ak
================================================
//// This module contains some basic Math utilities. Standard arithmetic
//// operations on integers are available through native operators:
////
//// Operator | Description
//// ---      | :---
//// `+`      | Arithmetic sum
//// `-`      | Arithmetic difference
//// `/`      | Whole division
//// `*`      | Arithmetic multiplication
//// `%`      | Remainder by whole division
////
//// Here are a few examples:
////
//// ```aiken
//// 1 + 1   // 2
//// 10 - 2  // 8
//// 40 / 14 // 2
//// 3 * 4   // 12
//// 10 % 3  // 1

use aiken/builtin

/// Calculate the absolute value of an integer.
///
/// ```aiken
/// math.abs(-42) == 42
/// math.abs(14) == 14
/// ```
pub fn abs(self: Int) -> Int {
  if self < 0 {
    0 - self
  } else {
    self
  }
}

test abs_1() {
  abs(14) == 14
}

test abs_2() {
  abs(-42) == 42
}

/// Restrict the value of an integer between two min and max bounds
///
/// ```aiken
/// math.clamp(14, min: 0, max: 10) == 10
/// ```
pub fn clamp(self: Int, min: Int, max: Int) -> Int {
  if self < min {
    min
  } else {
    if self > max {
      max
    } else {
      self
    }
  }
}

test clamp_1() {
  clamp(14, min: 0, max: 10) == 10
}

test clamp_2() {
  clamp(7, min: 0, max: 10) == 7
}

test clamp_3() {
  clamp(7, min: 10, max: 100) == 10
}

/// The greatest common divisor of two integers.
///
/// ```aiken
/// math.gcd(42, 14) == 14
/// math.gcd(14, 42) == 14
/// math.gcd(0, 0) == 0
/// ```
pub fn gcd(x: Int, y: Int) -> Int {
  abs(do_gcd(x, y))
}

fn do_gcd(x: Int, y: Int) -> Int {
  when y is {
    0 -> x
    _ -> do_gcd(y, x % y)
  }
}

test gcd_test1() {
  gcd(10, 300) == 10
}

test gcd_test2() {
  gcd(-10, 300) == 10
}

test gcd_test3() {
  gcd(42, 14) == 14
}

/// Checks if an integer has a given integer square root x.
/// The check has constant time complexity $O(1)$.
///
/// ```aiken
/// math.is_sqrt(0, 0)
/// math.is_sqrt(25, 5)
/// !math.is_sqrt(25, -5)
/// math.is_sqrt(44203, 210)
/// ```
pub fn is_sqrt(self: Int, x: Int) -> Bool {
  x * x <= self && ( x + 1 ) * ( x + 1 ) > self
}

test is_sqrt1() {
  is_sqrt(44203, 210)
}

test is_sqrt2() {
  is_sqrt(975461057789971041, 987654321)
}

/// The logarithm in base `b` of an element using integer divisions.
///
/// ```aiken
/// math.log(10, base: 2) == 3
/// math.log(42, base: 2) == 5
/// math.log(42, base: 3) == 3
/// math.log(5, base: 0) == 0
/// math.log(4, base: 4) == 1
/// math.log(4, base: 42) == 0
/// ```
pub fn log(self: Int, base: Int) -> Int {
  if base <= 0 {
    0
  } else if self == base {
    1
  } else if self < base {
    0
  } else {
    1 + log(self / base, base)
  }
}

test log_10_2() {
  log(10, base: 2) == 3
}

test log_42_2() {
  log(42, base: 2) == 5
}

test log_42_3() {
  log(42, base: 3) == 3
}

test log_5_0() {
  log(5, base: 0) == 0
}

test log_4_4() {
  log(4, base: 4) == 1
}

test log_4_43() {
  log(4, base: 43) == 0
}

/// The integer logarithm in base 2. Faster than [`log`](#log) in this particular case.
///
/// ```aiken
/// math.log2(1) == 0
/// math.log2(2) == 1
/// math.log2(3) == 1
/// math.log2(4) == 2
/// math.log2(256) == 8
/// math.log2(257) == 8
/// math.log2(511) == 8
/// math.log2(1025) == 10
/// ```
pub fn log2(x: Int) -> Int {
  expect x > 0
  let s = builtin.integer_to_bytearray(True, 0, x)
  let len = builtin.length_of_bytearray(s)
  let b = builtin.index_bytearray(s, 0)
  len * 8 - if b < 2 {
    8
  } else if b < 4 {
    7
  } else if b < 8 {
    6
  } else if b < 16 {
    5
  } else if b < 32 {
    4
  } else if b < 64 {
    3
  } else if b < 128 {
    2
  } else {
    1
  }
}

test log2_matrix() {
  and {
    log2(1) == 0,
    log2(2) == 1,
    log2(3) == 1,
    log2(4) == 2,
    log2(256) == 8,
    log2(257) == 8,
    log2(511) == 8,
    log2(1025) == 10,
  }
}

/// Return the maximum of two integers.
pub fn max(a: Int, b: Int) -> Int {
  if a > b {
    a
  } else {
    b
  }
}

test max_1() {
  max(0, 0) == 0
}

test max_2() {
  max(14, 42) == 42
}

test max_3() {
  max(42, 14) == 42
}

/// Return the minimum of two integers.
pub fn min(a: Int, b: Int) -> Int {
  if a > b {
    b
  } else {
    a
  }
}

test min_1() {
  min(0, 0) == 0
}

test min_2() {
  min(14, 42) == 14
}

test min_3() {
  min(42, 14) == 14
}

/// Calculates a number to the power of `e` using the exponentiation by
/// squaring method.
///
/// ```aiken
/// math.pow(3, 5) == 243
/// math.pow(7, 2) == 49
/// math.pow(3, -4) == 0
/// math.pow(0, 0) == 1
/// math.pow(513, 3) == 135005697
/// ```
pub fn pow(self: Int, e: Int) -> Int {
  if e < 0 {
    0
  } else if e == 0 {
    1
  } else if e % 2 == 0 {
    pow(self * self, e / 2)
  } else {
    self * pow(self * self, ( e - 1 ) / 2)
  }
}

test pow_3_5() {
  pow(3, 5) == 243
}

test pow_7_2() {
  pow(7, 2) == 49
}

test pow_3__4() {
  // negative powers round to zero
  pow(3, -4) == 0
}

test pow_0_0() {
  // sorry math
  pow(0, 0) == 1
}

test pow_513_3() {
  pow(513, 3) == 135005697
}

test pow_2_4() {
  pow(2, 4) == 16
}

test pow_2_42() {
  pow(2, 42) == 4398046511104
}

/// Calculates the power of 2 for a given exponent `e`. Much cheaper than
/// using `pow(2, _)` for small exponents $0 < e < 256$.
///
/// ```aiken
/// math.pow2(-2) == 0
/// math.pow2(0) == 1
/// math.pow2(1) == 2
/// math.pow2(4) == 16
/// math.pow2(42) == 4398046511104
/// ```
pub fn pow2(e: Int) -> Int {
  // do_pow2(e, 1)
  if e < 8 {
    if e < 0 {
      0
    } else {
      builtin.index_bytearray(#[1, 2, 4, 8, 16, 32, 64, 128], e)
    }
  } else if e < 32 {
    256 * pow2(e - 8)
  } else {
    4294967296 * pow2(e - 32)
  }
}

test pow2_neg() {
  pow2(-2) == 0
}

test pow2_0() {
  pow2(0) == 1
}

test pow2_1() {
  pow2(1) == 2
}

test pow2_4() {
  pow2(4) == 16
}

test pow2_42() {
  pow2(42) == 4398046511104
}

test pow2_256() {
  pow2(256) == 115792089237316195423570985008687907853269984665640564039457584007913129639936
}

/// Calculates the square root of an integer using the [Babylonian
/// method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method). This returns either the exact result or the smallest integer
/// nearest to the square root.
///
/// Returns `None` for negative values.
///
/// ```aiken
/// math.sqrt(0) == Some(0)
/// math.sqrt(25) == Some(5)
/// math.sqrt(44203) == Some(210)
/// math.sqrt(-42) == None
/// ```
///
/// > [!TIP]
/// > This function can be quite expensive to perform on-chain. Prefer using [`is_sqrt`](#is_sqrt) whenever possible.
pub fn sqrt(self: Int) -> Option<Int> {
  if self < 0 {
    None
  } else if self <= 1 {
    Some(self)
  } else {
    Some(sqrt_babylonian(self, self, ( self + 1 ) / 2))
  }
}

// The basic idea is that if x is an overestimate to the square root of a
// non-negative real number S then S/x will be an underestimate, or vice versa,
// and so the average of these two numbers may reasonably be expected to provide a
// better approximation (though the formal proof of that assertion depends on the
// inequality of arithmetic and geometric means that shows this average is always
// an overestimate of the square root.
fn sqrt_babylonian(self: Int, x: Int, y: Int) -> Int {
  if y >= x {
    x
  } else {
    sqrt_babylonian(self, y, ( y + self / y ) / 2)
  }
}

test sqrt1() {
  sqrt(0) == Some(0)
}

test sqrt2() {
  sqrt(1) == Some(1)
}

test sqrt3() {
  sqrt(25) == Some(5)
}

test sqrt4() {
  sqrt(44203) == Some(210)
}

test sqrt5() {
  sqrt(975461057789971041) == Some(987654321)
}

test sqrt6() {
  sqrt(-42) == None
}



================================================
FILE: lib/aiken/option.ak
================================================
//// A type to capture optional results; useful for handling errors.
////
//// Note that the `Option` type and its constructors are readily available in Aiken. They are part of the [Prelude](https://aiken-lang.github.io/prelude/aiken.html#Option) module imported by default in every module.

// ## Inspecting

/// Asserts whether an option is `None`.
pub fn is_none(self: Option<a>) -> Bool {
  when self is {
    Some(_) -> False
    _ -> True
  }
}

test is_none_1() {
  is_none(Some(0)) == False
}

test is_none_2() {
  is_none(None) == True
}

/// Asserts whether an option is `Some`, irrespective of the value it contains.
pub fn is_some(self: Option<a>) -> Bool {
  when self is {
    Some(_) -> True
    _ -> False
  }
}

test is_some_1() {
  is_some(Some(0)) == True
}

test is_some_2() {
  is_some(None) == False
}

// ## Combining

/// Chain together many computations that may fail.
///
/// ```aiken
/// self
///   |> dict.get(policy_id)
///   |> option.and_then(dict.get(_, asset_name))
///   |> option.or_else(0)
/// ```
pub fn and_then(
  self: Option<a>,
  then: fn(a) -> Option<result>,
) -> Option<result> {
  when self is {
    None -> None
    Some(a) -> then(a)
  }
}

fn try_decrement(n: Int) -> Option<Int> {
  if n > 0 {
    Some(n - 1)
  } else {
    None
  }
}

test and_then_1() {
  let result =
    None
      |> and_then(try_decrement)
  result == None
}

test and_then_2() {
  let result =
    Some(14)
      |> and_then(try_decrement)
  result == Some(13)
}

test and_then_3() {
  let result =
    Some(0)
      |> and_then(try_decrement)
  result == None
}

/// Picks the first element which is not None. If there's no such element, return None.
///
/// ```aiken
/// option.choice([]) == None
/// option.choice([Some(14), Some(42)]) == Some(14)
/// option.choice([None, Some(42)]) == Some(42)
/// option.choice([None, None]) == None
/// ```
pub fn choice(self: List<Option<a>>) -> Option<a> {
  when self is {
    [] -> None
    [head, ..others] ->
      when head is {
        None -> choice(others)
        _ -> head
      }
  }
}

test choice_1() {
  Some(1) == choice([Some(1), Some(2)])
}

test choice_2() {
  None == choice([])
}

test choice_3() {
  Some(1) == choice([None, Some(1)])
}

/// Converts from `Option<Option<a>>` to `Option<a>`.
///
/// ```aiken
/// option.flatten(Some(Some(42))) == Some(42)
/// option.flatten(Some(None)) == None
/// option.flatten(None) == None
/// ```
///
/// Flattening only removes one level of nesting at a time:
///
/// ```aiken
/// flatten(Some(Some(Some(42)))) == Some(Some(42))
/// Some(Some(Some(42))) |> flatten |> flatten == Some(42)
/// ```
pub fn flatten(opt: Option<Option<a>>) -> Option<a> {
  when opt is {
    Some(inner) -> inner
    None -> None
  }
}

test flatten_1() {
  let x: Option<Option<Int>> = Some(Some(6))
  Some(6) == flatten(x)
}

test flatten_2() {
  let x: Option<Option<Int>> = Some(None)
  None == flatten(x)
}

test flatten_3() {
  let x: Option<Option<Int>> = None
  None == flatten(x)
}

test flatten_4() {
  let x: Option<Option<Option<Int>>> = Some(Some(Some(6)))

  let result =
    x
      |> flatten
      |> flatten

  Some(6) == result
}

/// Apply a function to the inner value of an [`Option`](#option)
///
/// ```aiken
/// option.map(None, fn(n) { n * 2 }) == None
/// option.map(Some(14), fn(n) { n * 2 }) == Some(28)
/// ```
pub fn map(self: Option<a>, with: fn(a) -> result) -> Option<result> {
  when self is {
    None -> None
    Some(a) -> Some(with(a))
  }
}

test map_1() {
  map(None, fn(_) { Void }) == None
}

test map_2() {
  map(Some(14), fn(n) { n + 1 }) == Some(15)
}

/// Combine two [`Option`](#option) together.
///
/// ```aiken
/// type Foo {
///   Foo(Int, Int)
/// }
///
/// option.map2(Some(14), Some(42), Foo) == Some(Foo(14, 42))
/// option.map2(None, Some(42), Foo) == None
/// option.map2(Some(14), None, Foo) == None
/// ```
pub fn map2(
  opt_a: Option<a>,
  opt_b: Option<b>,
  with: fn(a, b) -> result,
) -> Option<result> {
  when opt_a is {
    None -> None
    Some(a) ->
      when opt_b is {
        None -> None
        Some(b) -> Some(with(a, b))
      }
  }
}

test map2_1() {
  map2(None, Some(42), fn(_, _) { 14 }) == None
}

test map2_2() {
  map2(Some(42), None, fn(_, _) { 14 }) == None
}

test map2_3() {
  map2(Some(14), Some(42), fn(a, b) { (a, b) }) == Some((14, 42))
}

/// Combine three [`Option`](#option) together.
///
/// ```aiken
/// type Foo {
///   Foo(Int, Int, Int)
/// }
///
/// option.map3(Some(14), Some(42), Some(1337), Foo) == Some(Foo(14, 42, 1337))
/// option.map3(None, Some(42), Some(1337), Foo) == None
/// option.map3(Some(14), None, None, Foo) == None
/// ```
pub fn map3(
  opt_a: Option<a>,
  opt_b: Option<b>,
  opt_c: Option<c>,
  with: fn(a, b, c) -> result,
) -> Option<result> {
  when opt_a is {
    None -> None
    Some(a) ->
      when opt_b is {
        None -> None
        Some(b) ->
          when opt_c is {
            None -> None
            Some(c) -> Some(with(a, b, c))
          }
      }
  }
}

test map3_1() {
  map3(None, Some(42), None, fn(_, _, _) { 14 }) == None
}

test map3_2() {
  map3(Some(42), None, None, fn(_, _, _) { 14 }) == None
}

test map3_3() {
  map3(Some(14), Some(42), Some(1337), fn(a, b, c) { c - a + b }) == Some(1365)
}

/// Like [`or_else`](#or_else) but allows returning an `Option`.
/// This is effectively mapping the error branch.
///
/// ```aiken
/// option.or_try(None, fn(_) { Some("aiken") }) == Some("aiken")
/// option.or_try(Some(42), fn(_) { Some(14) }) == Some(42)
/// option.or_try(None, fn (_) { fail }) => ðŸ’¥
/// ```
pub fn or_try(self: Option<a>, compute_default: fn() -> Option<a>) -> Option<a> {
  when self is {
    None -> compute_default()
    _ -> self
  }
}

test or_try_1() {
  or_try(None, fn() { Some("aiken") }) == Some("aiken")
}

test or_try_2() {
  or_try(Some(42), fn() { fail }) == Some(42)
}

// ## Transforming

/// Provide a default value, turning an optional value into a normal value.
///
/// ```aiken
/// option.or_else(None, "aiken") == "aiken"
/// option.or_else(Some(42), 14) == 42
/// ```
pub fn or_else(self: Option<a>, default: a) -> a {
  when self is {
    None -> default
    Some(a) -> a
  }
}

test or_else_1() {
  or_else(None, "aiken") == "aiken"
}

test or_else_2() {
  or_else(Some(42), 14) == 42
}



================================================
FILE: lib/aiken/collection/dict.ak
================================================
//// A module for working with bytearray dictionaries.
////
////
//// > [!IMPORTANT]
//// >
//// > Dictionaries are **ordered sets** of key-value pairs, which thus
//// > preserve some invariants. Specifically, each key is only present once in
//// > the dictionary and all keys are stored in ascending lexicographic order.
//// >
//// > These invariants allow for more optimized functions to operate on `Dict`,
//// > but as a trade-offs, prevent `Dict` from being serializable. To recover a `Dict`
//// > from an unknown `Data`, you must first recover an `Pairs<k, v>` and use
//// > [`dict.from_ascending_list`](#from_ascending_list).

use aiken/builtin
use aiken/collection/dict/strategy.{UnionStrategy}

/// An opaque `Dict`. The type is opaque because the module maintains some
/// invariant, namely: there's only one occurrence of a given key in the dictionary.
///
/// Note that the `key` parameter is a phantom-type, and only present as a
/// means of documentation. Keys can be any type, yet will need to comparable
/// to use functions like `insert`.
///
/// See for example:
///
/// ```aiken
/// pub type Value =
///   Dict<PolicyId, Dict<AssetName, Int>>
/// ```
pub opaque type Dict<key, value> {
  inner: Pairs<ByteArray, value>,
}

// ## Constructing

/// An empty dictionnary.
/// ```aiken
/// dict.to_pairs(dict.empty) == []
/// ```
pub const empty: Dict<key, value> = Dict { inner: [] }

const foo = #"666f6f"

const bar = #"626172"

const baz = #"62617a"

const fixture_1 =
  empty
    |> insert(foo, 42)
    |> insert(bar, 14)

/// Like ['from_pairs'](#from_pairs), but from an already sorted list by ascending
/// keys. This function fails (i.e. halts the program execution) if the list isn't
/// sorted.
///
/// ```aiken
/// let pairs = [Pair("a", 100), Pair("b", 200), Pair("c", 300)]
///
/// let result =
///   dict.from_ascending_pairs(pairs)
///     |> dict.to_pairs()
///
/// result == [Pair("a", 100), Pair("b", 200), Pair("c", 300)]
/// ```
///
/// This is meant to be used to turn a list constructed off-chain into a `Dict`
/// which has taken care of maintaining interval invariants. This function still
/// performs a sanity check on all keys to avoid silly mistakes. It is, however,
/// considerably faster than ['from_pairs'](from_pairs)
pub fn from_ascending_pairs(xs: Pairs<ByteArray, value>) -> Dict<key, value> {
  let Void = check_ascending_list(xs)
  Dict { inner: xs }
}

fn check_ascending_list(xs: Pairs<ByteArray, value>) {
  when xs is {
    [] -> Void
    [_] -> Void
    [Pair(x0, _), Pair(x1, _) as e, ..rest] ->
      if builtin.less_than_bytearray(x0, x1) {
        check_ascending_list([e, ..rest])
      } else {
        fail @"keys in associative list aren't in ascending order"
      }
  }
}

/// Like [`from_ascending_pairs`](#from_ascending_pairs) but fails if **any**
/// value doesn't satisfy the predicate.
///
/// ```aiken
/// let pairs = [Pair("a", 100), Pair("b", 200), Pair("c", 300)]
///
/// dict.from_ascending_pairs_with(pairs, fn(x) { x <= 250 }) // fail
/// ```
pub fn from_ascending_pairs_with(
  xs: Pairs<ByteArray, value>,
  predicate: fn(value) -> Bool,
) -> Dict<key, value> {
  let Void = check_ascending_pairs_with(xs, predicate)
  Dict { inner: xs }
}

fn check_ascending_pairs_with(
  xs: Pairs<ByteArray, value>,
  predicate: fn(value) -> Bool,
) {
  when xs is {
    [] -> Void
    [Pair(_, v)] ->
      if predicate(v) {
        Void
      } else {
        fail @"value doesn't satisfy predicate"
      }
    [Pair(x0, v0), Pair(x1, _) as e, ..rest] ->
      if builtin.less_than_bytearray(x0, x1) {
        if predicate(v0) {
          check_ascending_pairs_with([e, ..rest], predicate)
        } else {
          fail @"value doesn't satisfy predicate"
        }
      } else {
        fail @"keys in pairs aren't in ascending order"
      }
  }
}

test bench_from_ascending_pairs() {
  let dict =
    from_ascending_pairs(
      [
        Pair("aaaa", 1), Pair("aaab", 9), Pair("aaba", 5), Pair("aabb", 13),
        Pair("abaa", 2), Pair("abab", 10), Pair("abba", 6), Pair("abbb", 14),
        Pair("baaa", 3), Pair("baab", 11), Pair("baba", 7), Pair("babb", 15),
        Pair("bbaa", 4), Pair("bbab", 12), Pair("bbba", 8), Pair("bbbb", 16),
      ],
    )

  size(dict) == 16
}

/// Construct a dictionary from a list of key-value pairs. Note that when a key is present
/// multiple times, the first occurrence prevails.
///
/// ```aiken
/// let pairs = [Pair("a", 100), Pair("c", 300), Pair("b", 200)]
///
/// let result =
///   dict.from_pairs(pairs)
///     |> dict.to_pairs()
///
/// result == [Pair("a", 100), Pair("b", 200), Pair("c", 300)]
/// ```
pub fn from_pairs(self: Pairs<ByteArray, value>) -> Dict<key, value> {
  Dict { inner: do_from_pairs(self) }
}

fn do_from_pairs(xs: Pairs<ByteArray, value>) -> Pairs<ByteArray, value> {
  when xs is {
    [] -> []
    [Pair(k, v), ..rest] ->
      do_insert_with(do_from_pairs(rest), k, v, strategy.keep_left())
  }
}

test from_list_1() {
  from_pairs([]) == empty
}

test from_list_2() {
  from_pairs([Pair(foo, 42), Pair(bar, 14)]) == from_pairs(
    [Pair(bar, 14), Pair(foo, 42)],
  )
}

test from_list_3() {
  from_pairs([Pair(foo, 42), Pair(bar, 14)]) == fixture_1
}

test from_list_4() {
  from_pairs([Pair(foo, 42), Pair(bar, 14), Pair(foo, 1337)]) == fixture_1
}

test bench_from_pairs() {
  let dict =
    from_pairs(
      [
        Pair("bbba", 8), Pair("bbab", 12), Pair("aabb", 13), Pair("aaab", 9),
        Pair("bbbb", 16), Pair("aaaa", 1), Pair("aaba", 5), Pair("abab", 10),
        Pair("baba", 7), Pair("baab", 11), Pair("abaa", 2), Pair("baaa", 3),
        Pair("bbaa", 4), Pair("babb", 15), Pair("abbb", 14), Pair("abba", 6),
      ],
    )

  size(dict) == 16
}

// ## Inspecting

/// Finds a value in the dictionary, and returns the first key found to have that value.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert(key: "a", value: 42)
///     |> dict.insert(key: "b", value: 14)
///     |> dict.insert(key: "c", value: 42)
///     |> dict.find(42)
///
/// result == Some("a")
/// ```
pub fn find(self: Dict<key, value>, value v: value) -> Option<ByteArray> {
  do_find(self.inner, v)
}

fn do_find(self: Pairs<ByteArray, value>, value v: value) -> Option<ByteArray> {
  when self is {
    [] -> None
    [Pair(k2, v2), ..rest] ->
      if v == v2 {
        Some(k2)
      } else {
        do_find(rest, v)
      }
  }
}

test find_1() {
  find(empty, foo) == None
}

test find_2() {
  find(
    empty
      |> insert(foo, 14),
    14,
  ) == Some(foo)
}

test find_3() {
  find(
    empty
      |> insert(foo, 14),
    42,
  ) == None
}

test find_4() {
  find(
    empty
      |> insert(foo, 14)
      |> insert(bar, 42)
      |> insert(baz, 14),
    14,
  ) == Some(baz)
}

/// Get a value in the dict by its key.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert(key: "a", value: "Aiken")
///     |> dict.get(key: "a")
///
///  result == Some("Aiken")
/// ```
pub fn get(self: Dict<key, value>, key: ByteArray) -> Option<value> {
  do_get(self.inner, key, Some, fn() { None })
}

/// Get a value from the dict by its key, or fallback to a default one.
///
/// ```aiken
/// let kvs =
///   dict.empty
///     |> dict.insert(key: "a", value: 42)
///     |> dict.insert(key: "b", value: 14)
///
/// dict.get_or_else(kvs, "a", fn() { 0 }) == 42
/// dict.get_or_else(kvs, "b", fn() { 0 }) == 14
/// dict.get_or_else(kvs, "c", fn() { 0 }) == 0
/// ```
pub fn get_or_else(
  self: Dict<key, value>,
  key: ByteArray,
  or_else: fn() -> value,
) -> value {
  do_get(self.inner, key, identity, or_else)
}

fn do_get(
  self: Pairs<ByteArray, value>,
  key k: ByteArray,
  return: fn(value) -> result,
  or_else: fn() -> result,
) -> result {
  when self is {
    [] -> or_else()
    [Pair(k2, v), ..rest] ->
      if builtin.less_than_equals_bytearray(k, k2) {
        if k == k2 {
          return(v)
        } else {
          or_else()
        }
      } else {
        do_get(rest, k, return, or_else)
      }
  }
}

test get_1() {
  get(empty, foo) == None
}

test get_or_else_1() {
  get_or_else(empty, foo, fn() { 0 }) == 0
}

test get_2() {
  let m =
    empty
      |> insert(foo, "Aiken")
      |> insert(bar, "awesome")
  get(m, key: foo) == Some("Aiken")
}

test get_or_else_2() {
  let m =
    empty
      |> insert(foo, "Aiken")
      |> insert(bar, "awesome")
  get_or_else(m, key: foo, or_else: fn() { "" }) == "Aiken"
}

test get_3() {
  let m =
    empty
      |> insert(foo, "Aiken")
      |> insert(bar, "awesome")
  get(m, key: baz) == None
}

test get_or_else_3() {
  let m =
    empty
      |> insert(foo, "Aiken")
      |> insert(bar, "awesome")
  get_or_else(m, key: baz, or_else: fn() { "missing?" }) == "missing?"
}

test get_4() {
  let m =
    empty
      |> insert("aaa", "1")
      |> insert("bbb", "2")
      |> insert("ccc", "3")
      |> insert("ddd", "4")
      |> insert("eee", "5")
      |> insert("fff", "6")
      |> insert("ggg", "7")
      |> insert("hhh", "8")
      |> insert("iii", "9")
      |> insert("jjj", "10")

  get(m, "bcd") == None
}

test get_or_else_4() {
  let m =
    empty
      |> insert("aaa", "1")
      |> insert("bbb", "2")
      |> insert("ccc", "3")
      |> insert("ddd", "4")
      |> insert("eee", "5")
      |> insert("fff", "6")
      |> insert("ggg", "7")
      |> insert("hhh", "8")
      |> insert("iii", "9")
      |> insert("jjj", "10")

  get_or_else(m, "bcd", fn() { "0" }) == "0"
}

test get_5() {
  let m =
    empty
      |> insert("aaa", "1")
      |> insert("bbb", "2")
      |> insert("ccc", "3")
      |> insert("ddd", "4")
      |> insert("eee", "5")
      |> insert("fff", "6")
      |> insert("ggg", "7")
      |> insert("hhh", "8")
      |> insert("iii", "9")
      |> insert("jjj", "10")

  get(m, "kkk") == None
}

test get_or_else_5() {
  let m =
    empty
      |> insert("aaa", "1")
      |> insert("bbb", "2")
      |> insert("ccc", "3")
      |> insert("ddd", "4")
      |> insert("eee", "5")
      |> insert("fff", "6")
      |> insert("ggg", "7")
      |> insert("hhh", "8")
      |> insert("iii", "9")
      |> insert("jjj", "10")

  get_or_else(m, "kkk", fn() { "" }) == ""
}

/// Check if a key exists in the dictionary.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert(key: "a", value: "Aiken")
///     |> dict.has_key("a")
///
/// result == True
/// ```
pub fn has_key(self: Dict<key, value>, key k: ByteArray) -> Bool {
  do_has_key(self.inner, k)
}

fn do_has_key(self: Pairs<ByteArray, value>, key k: ByteArray) -> Bool {
  when self is {
    [] -> False
    [Pair(k2, _), ..rest] ->
      if builtin.less_than_equals_bytearray(k, k2) {
        k == k2
      } else {
        do_has_key(rest, k)
      }
  }
}

test has_key_1() {
  !has_key(empty, foo)
}

test has_key_2() {
  has_key(
    empty
      |> insert(foo, 14),
    foo,
  )
}

test has_key_3() {
  !has_key(
    empty
      |> insert(foo, 14),
    bar,
  )
}

test has_key_4() {
  has_key(
    empty
      |> insert(foo, 14)
      |> insert(bar, 42),
    bar,
  )
}

/// Efficiently checks whether a dictionary is empty.
/// ```aiken
/// dict.is_empty(dict.empty) == True
/// ```
pub fn is_empty(self: Dict<key, value>) -> Bool {
  when self.inner is {
    [] -> True
    _ -> False
  }
}

test is_empty_1() {
  is_empty(empty)
}

/// Extract all the keys present in a given `Dict`.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert("a", 14)
///     |> dict.insert("b", 42)
///     |> dict.insert("a", 1337)
///     |> dict.keys()
///
/// result == ["a", "b"]
/// ```
pub fn keys(self: Dict<key, value>) -> List<ByteArray> {
  do_keys(self.inner)
}

fn do_keys(self: Pairs<ByteArray, value>) -> List<ByteArray> {
  when self is {
    [] -> []
    [Pair(k, _), ..rest] -> [k, ..do_keys(rest)]
  }
}

test keys_1() {
  keys(empty) == []
}

test keys_2() {
  keys(
    empty
      |> insert(foo, 0)
      |> insert(bar, 0),
  ) == [bar, foo]
}

/// Return the number of key-value pairs in the dictionary.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert("a", 100)
///     |> dict.insert("b", 200)
///     |> dict.insert("c", 300)
///     |> dict.size()
///
/// result == 3
/// ```
pub fn size(self: Dict<key, value>) -> Int {
  do_size(self.inner)
}

fn do_size(self: Pairs<key, value>) -> Int {
  when self is {
    [] -> 0
    [_, ..rest] -> 1 + do_size(rest)
  }
}

test size_1() {
  size(empty) == 0
}

test size_2() {
  size(
    empty
      |> insert(foo, 14),
  ) == 1
}

test size_3() {
  size(
    empty
      |> insert(foo, 14)
      |> insert(bar, 42),
  ) == 2
}

/// Extract all the values present in a given `Dict`.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert("a", 14)
///     |> dict.insert("b", 42)
///     |> dict.insert("c", 1337)
///     |> dict.values()
///
/// result == [14, 42, 1337]
/// ```
pub fn values(self: Dict<key, value>) -> List<value> {
  do_values(self.inner)
}

fn do_values(self: Pairs<key, value>) -> List<value> {
  when self is {
    [] -> []
    [Pair(_, v), ..rest] -> [v, ..do_values(rest)]
  }
}

test values_1() {
  values(empty) == []
}

test values_2() {
  values(
    empty
      |> insert(foo, 3)
      |> insert(bar, 4),
  ) == [4, 3]
}

// ## Modifying

/// Remove a key-value pair from the dictionary. If the key is not found, no changes are made.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert(key: "a", value: 100)
///     |> dict.insert(key: "b", value: 200)
///     |> dict.delete(key: "a")
///     |> dict.to_pairs()
///
/// result == [Pair("b", 200)]
/// ```
pub fn delete(self: Dict<key, value>, key: ByteArray) -> Dict<key, value> {
  Dict { inner: do_delete(self.inner, key) }
}

fn do_delete(
  self: Pairs<ByteArray, value>,
  key k: ByteArray,
) -> Pairs<ByteArray, value> {
  when self is {
    [] -> []
    [Pair(k2, v2), ..rest] ->
      if builtin.less_than_equals_bytearray(k, k2) {
        if k == k2 {
          rest
        } else {
          self
        }
      } else {
        [Pair(k2, v2), ..do_delete(rest, k)]
      }
  }
}

test delete_1() {
  delete(empty, foo) == empty
}

test delete_2() {
  let m =
    empty
      |> insert(foo, 14)
  delete(m, foo) == empty
}

test delete_3() {
  let m =
    empty
      |> insert(foo, 14)
  delete(m, bar) == m
}

test delete_4() {
  let m =
    empty
      |> insert(foo, 14)
      |> insert(bar, 14)
  !has_key(delete(m, foo), foo)
}

test delete_5() {
  let m =
    empty
      |> insert(foo, 14)
      |> insert(bar, 14)
  has_key(delete(m, bar), foo)
}

test delete_6() {
  let m =
    empty
      |> insert("aaa", 1)
      |> insert("bbb", 2)
      |> insert("ccc", 3)
      |> insert("ddd", 4)
      |> insert("eee", 5)
      |> insert("fff", 6)
      |> insert("ggg", 7)
      |> insert("hhh", 8)
      |> insert("iii", 9)
      |> insert("jjj", 10)

  delete(m, "bcd") == m
}

/// Keep only the key-value pairs that pass the given predicate.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert(key: "a", value: 100)
///     |> dict.insert(key: "b", value: 200)
///     |> dict.insert(key: "c", value: 300)
///     |> dict.filter(fn(k, _v) { k != "a" })
///     |> dict.to_pairs()
///
/// result == [Pair("b", 200), Pair("c", 300)]
/// ```
pub fn filter(
  self: Dict<key, value>,
  with: fn(ByteArray, value) -> Bool,
) -> Dict<key, value> {
  Dict { inner: do_filter(self.inner, with) }
}

fn do_filter(
  self: Pairs<ByteArray, value>,
  with: fn(ByteArray, value) -> Bool,
) -> Pairs<ByteArray, value> {
  when self is {
    [] -> []
    [Pair(k, v), ..rest] ->
      if with(k, v) {
        [Pair(k, v), ..do_filter(rest, with)]
      } else {
        do_filter(rest, with)
      }
  }
}

test filter_1() {
  filter(empty, fn(_, _) { True }) == empty
}

test filter_2() {
  let expected =
    empty
      |> insert(foo, 42)
  filter(fixture_1, fn(_, v) { v > 14 }) == expected
}

test filter_3() {
  let expected =
    empty
      |> insert(bar, 14)
  filter(fixture_1, fn(k, _) { k == bar }) == expected
}

/// Insert a value in the dictionary at a given key. If the key already exists, its value is **overridden**. If you need ways to combine keys together, use (`insert_with`)[#insert_with].
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert(key: "a", value: 1)
///     |> dict.insert(key: "b", value: 2)
///     |> dict.insert(key: "a", value: 3)
///     |> dict.to_pairs()
///
/// result == [Pair("a", 3), Pair("b", 2)]
/// ```
pub fn insert(
  self: Dict<key, value>,
  key k: ByteArray,
  value v: value,
) -> Dict<key, value> {
  Dict { inner: do_insert(self.inner, k, v) }
}

fn do_insert(
  self: Pairs<ByteArray, value>,
  key k: ByteArray,
  value v: value,
) -> Pairs<ByteArray, value> {
  when self is {
    [] -> [Pair(k, v)]
    [Pair(k2, v2), ..rest] ->
      if builtin.less_than_bytearray(k, k2) {
        [Pair(k, v), ..self]
      } else {
        if k == k2 {
          [Pair(k, v), ..rest]
        } else {
          [Pair(k2, v2), ..do_insert(rest, k, v)]
        }
      }
  }
}

test insert_1() {
  let m1 =
    empty
      |> insert(foo, 42)
  let m2 =
    empty
      |> insert(foo, 14)
  insert(m1, foo, 14) == m2
}

test insert_2() {
  let m1 =
    empty
      |> insert(foo, 42)
  let m2 =
    empty
      |> insert(bar, 14)
  insert(m1, bar, 14) == insert(m2, foo, 42)
}

/// Insert a value in the dictionary at a given key. When the key already exist, the provided
/// merge function is called. The value existing in the dictionary is passed as the second argument
/// to the merge function, and the new value is passed as the third argument.
///
/// ```aiken
/// use aiken/collection/dict/union
///
/// let result =
///   dict.empty
///     |> dict.insert_with(key: "a", value: 1, with: strategy.sum())
///     |> dict.insert_with(key: "b", value: 2, with: strategy.sum())
///     |> dict.insert_with(key: "a", value: 3, with: strategy.sum())
///     |> dict.to_pairs()
///
/// result == [Pair("a", 4), Pair("b", 2)]
/// ```
pub fn insert_with(
  self: Dict<key, value>,
  key k: ByteArray,
  value v: value,
  with: UnionStrategy<ByteArray, value>,
) -> Dict<key, value> {
  Dict {
    inner: do_insert_with(
      self.inner,
      k,
      v,
      fn(k, v1, v2, some, none) { with(k, v2, v1, some, none) },
    ),
  }
}

test insert_with_1() {
  let result =
    empty
      |> insert_with(key: "foo", value: 1, with: strategy.sum())
      |> insert_with(key: "bar", value: 2, with: strategy.sum())
      |> to_pairs()

  result == [Pair("bar", 2), Pair("foo", 1)]
}

test insert_with_2() {
  let result =
    empty
      |> insert_with(key: "foo", value: 1, with: strategy.sum())
      |> insert_with(key: "bar", value: 2, with: strategy.sum())
      |> insert_with(key: "foo", value: 3, with: strategy.sum())
      |> to_pairs()

  result == [Pair("bar", 2), Pair("foo", 4)]
}

test insert_with_3() {
  let with =
    fn(k, a, _b, keep, discard) {
      if k == "foo" {
        keep(a)
      } else {
        discard()
      }
    }

  let result =
    empty
      |> insert_with(key: "foo", value: 1, with: with)
      |> insert_with(key: "bar", value: 2, with: with)
      |> insert_with(key: "foo", value: 3, with: with)
      |> insert_with(key: "bar", value: 4, with: with)
      |> to_pairs()

  result == [Pair("foo", 1)]
}

/// Apply a function to all key-value pairs in a Dict.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert("a", 100)
///     |> dict.insert("b", 200)
///     |> dict.insert("c", 300)
///     |> dict.map(fn(_k, v) { v * 2 })
///     |> dict.to_pairs()
///
///  result == [Pair("a", 200), Pair("b", 400), Pair("c", 600)]
/// ```
pub fn map(self: Dict<key, a>, with: fn(ByteArray, a) -> b) -> Dict<key, b> {
  Dict { inner: do_map(self.inner, with) }
}

fn do_map(
  self: Pairs<ByteArray, a>,
  with: fn(ByteArray, a) -> b,
) -> Pairs<ByteArray, b> {
  when self is {
    [] -> []
    [Pair(k, v), ..rest] -> [Pair(k, with(k, v)), ..do_map(rest, with)]
  }
}

test map_1() {
  let result =
    fixture_1
      |> map(with: fn(k, _) { k })
  get(result, foo) == Some(foo)
}

test map_2() {
  let result =
    fixture_1
      |> map(with: fn(_, v) { v + 1 })
  get(result, foo) == Some(43) && size(result) == size(fixture_1)
}

/// Remove a key-value pair from the dictionary and return its value. If the key is not found, no changes are made.
///
/// ```aiken
/// let (value, _) =
///   dict.empty
///     |> dict.insert(key: "a", value: 100)
///     |> dict.insert(key: "b", value: 200)
///     |> dict.pop(key: "a")
///
/// result == 100
/// ```
pub fn pop(
  self: Dict<key, value>,
  key: ByteArray,
) -> (Option<value>, Dict<key, value>) {
  do_pop(self.inner, key, fn(value, inner) { (value, Dict { inner }) })
}

fn do_pop(
  self: Pairs<ByteArray, value>,
  key k: ByteArray,
  return: fn(Option<value>, Pairs<ByteArray, value>) -> result,
) -> result {
  when self is {
    [] -> return(None, [])
    [Pair(k2, v2), ..rest] ->
      if builtin.less_than_equals_bytearray(k, k2) {
        if k == k2 {
          return(Some(v2), rest)
        } else {
          return(None, self)
        }
      } else {
        do_pop(
          rest,
          k,
          fn(value, inner) { return(value, [Pair(k2, v2), ..inner]) },
        )
      }
  }
}

test pop_1() {
  pop(empty, foo) == (None, empty)
}

test pop_2() {
  let m =
    empty
      |> insert(foo, 14)
  pop(m, foo) == (Some(14), empty)
}

test pop_3() {
  let m =
    empty
      |> insert(foo, 14)
  pop(m, bar) == (None, m)
}

test pop_4() {
  let m =
    empty
      |> insert(foo, 14)
      |> insert(bar, 14)
  pop(m, foo) == (Some(14), empty |> insert(bar, 14))
}

test pop_6() {
  let m =
    empty
      |> insert("aaa", 1)
      |> insert("bbb", 2)
      |> insert("ccc", 3)
      |> insert("ddd", 4)
      |> insert("eee", 5)
      |> insert("fff", 6)
      |> insert("ggg", 7)
      |> insert("hhh", 8)
      |> insert("iii", 9)
      |> insert("jjj", 10)

  pop(m, "bcd") == (None, m)
}

// ## Combining

/// Combine two dictionaries. If the same key exist in both the left and
/// right dictionary, values from the left are preferred (i.e. left-biaised).
///
/// ```aiken
/// let left_dict = dict.from_pairs([Pair("a", 100), Pair("b", 200)])
/// let right_dict = dict.from_pairs([Pair("a", 150), Pair("c", 300)])
///
/// let result =
///   dict.union(left_dict, right_dict) |> dict.to_pairs()
///
/// result == [Pair("a", 100), Pair("b", 200), Pair("c", 300)]
/// ```
pub fn union(
  left: Dict<key, value>,
  right: Dict<key, value>,
) -> Dict<key, value> {
  Dict { inner: do_union(left.inner, right.inner) }
}

fn do_union(
  left: Pairs<ByteArray, value>,
  right: Pairs<ByteArray, value>,
) -> Pairs<ByteArray, value> {
  when left is {
    [] -> right
    [Pair(k, v), ..rest] -> do_union(rest, do_insert(right, k, v))
  }
}

test union_1() {
  union(fixture_1, empty) == fixture_1
}

test union_2() {
  union(empty, fixture_1) == fixture_1
}

test union_3() {
  let left =
    empty
      |> insert(foo, 14)
  let right =
    empty
      |> insert(bar, 42)
      |> insert(baz, 1337)
  union(left, right) == from_pairs(
    [Pair(foo, 14), Pair(baz, 1337), Pair(bar, 42)],
  )
}

test union_4() {
  let left =
    empty
      |> insert(foo, 14)
  let right =
    empty
      |> insert(bar, 42)
      |> insert(foo, 1337)
  union(left, right) == from_pairs([Pair(foo, 14), Pair(bar, 42)])
}

/// Like [`union`](#union) but allows specifying the behavior to adopt when a key is present
/// in both dictionaries. The first value received correspond to the value in the left
/// dictionnary, whereas the second argument corresponds to the value in the right dictionnary.
///
/// When passing `None`, the value is removed and not present in the union.
///
/// ```aiken
/// let left_dict = dict.from_pairs([Pair("a", 100), Pair("b", 200)])
/// let right_dict = dict.from_pairs([Pair("a", 150), Pair("c", 300)])
///
/// let result =
///   dict.union_with(
///     left_dict,
///     right_dict,
///     fn(_k, v1, v2) { Some(v1 + v2) },
///   )
///     |> dict.to_pairs()
///
/// result == [Pair("a", 250), Pair("b", 200), Pair("c", 300)]
/// ```
pub fn union_with(
  left: Dict<key, value>,
  right: Dict<key, value>,
  with: UnionStrategy<ByteArray, value>,
) -> Dict<key, value> {
  Dict { inner: do_union_with(left.inner, right.inner, with) }
}

fn do_union_with(
  left: Pairs<ByteArray, value>,
  right: Pairs<ByteArray, value>,
  with: UnionStrategy<ByteArray, value>,
) -> Pairs<ByteArray, value> {
  when left is {
    [] -> right
    [Pair(k, v), ..rest] ->
      do_union_with(rest, do_insert_with(right, k, v, with), with)
  }
}

fn do_insert_with(
  self: Pairs<ByteArray, value>,
  key k: ByteArray,
  value v: value,
  with: UnionStrategy<ByteArray, value>,
) -> Pairs<ByteArray, value> {
  when self is {
    [] -> [Pair(k, v)]
    [Pair(k2, v2), ..rest] ->
      if builtin.less_than_bytearray(k, k2) {
        [Pair(k, v), ..self]
      } else {
        if k == k2 {
          with(
            k,
            v,
            v2,
            fn(combined) { [Pair(k, combined), ..rest] },
            fn() { rest },
          )
        } else {
          [Pair(k2, v2), ..do_insert_with(rest, k, v, with)]
        }
      }
  }
}

test union_with_1() {
  let left =
    empty
      |> insert(foo, 14)

  let right =
    empty
      |> insert(bar, 42)
      |> insert(foo, 1337)

  let result = union_with(left, right, with: strategy.sum())

  result == from_pairs([Pair(foo, 1351), Pair(bar, 42)])
}

// ## Transforming

/// Fold over the key-value pairs in a dictionary. The fold direction follows keys
/// in ascending order and is done from left-to-right.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert(key: "a", value: 100)
///     |> dict.insert(key: "b", value: 200)
///     |> dict.insert(key: "c", value: 300)
///     |> dict.foldl(0, fn(_k, v, r) { v + r })
///
/// result == 600
/// ```
pub fn foldl(
  self: Dict<key, value>,
  zero: result,
  with: fn(ByteArray, value, result) -> result,
) -> result {
  do_foldl(self.inner, zero, with)
}

fn do_foldl(
  self: Pairs<ByteArray, value>,
  zero: result,
  with: fn(ByteArray, value, result) -> result,
) -> result {
  when self is {
    [] -> zero
    [Pair(k, v), ..rest] -> do_foldl(rest, with(k, v, zero), with)
  }
}

test fold_1() {
  foldl(empty, 14, fn(_, _, _) { 42 }) == 14
}

test fold_2() {
  foldl(fixture_1, zero: 0, with: fn(_, v, total) { v + total }) == 56
}

/// Fold over the key-value pairs in a dictionary. The fold direction follows keys
/// in ascending order and is done from right-to-left.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert(key: "a", value: 100)
///     |> dict.insert(key: "b", value: 200)
///     |> dict.insert(key: "c", value: 300)
///     |> dict.foldr(0, fn(_k, v, r) { v + r })
///
/// result == 600
/// ```
pub fn foldr(
  self: Dict<key, value>,
  zero: result,
  with: fn(ByteArray, value, result) -> result,
) -> result {
  do_foldr(self.inner, zero, with)
}

fn do_foldr(
  self: Pairs<ByteArray, value>,
  zero: result,
  with: fn(ByteArray, value, result) -> result,
) -> result {
  when self is {
    [] -> zero
    [Pair(k, v), ..rest] -> with(k, v, do_foldr(rest, zero, with))
  }
}

test foldr_1() {
  foldr(empty, 14, fn(_, _, _) { 42 }) == 14
}

test foldr_2() {
  foldr(fixture_1, zero: 0, with: fn(_, v, total) { v + total }) == 56
}

/// Get the inner list holding the dictionary data.
///
/// ```aiken
/// let result =
///   dict.empty
///     |> dict.insert("a", 100)
///     |> dict.insert("b", 200)
///     |> dict.insert("c", 300)
///     |> dict.to_pairs()
///
/// result == [Pair("a", 100), Pair("b", 200), Pair("c", 300)]
/// ```
pub fn to_pairs(self: Dict<key, value>) -> Pairs<ByteArray, value> {
  self.inner
}

test to_list_1() {
  to_pairs(empty) == []
}

test to_list_2() {
  to_pairs(fixture_1) == [Pair(bar, 14), Pair(foo, 42)]
}



================================================
FILE: lib/aiken/collection/list.ak
================================================
use aiken/builtin
use aiken/primitive/bytearray
use aiken/primitive/int

// ## Constructing

/// Add an element in front of the list. Sometimes useful when combined with
/// other functions.
///
/// ```aiken
/// list.push([2, 3], 1) == [1, ..[2, 3]] == [1, 2, 3]
/// ```
pub fn push(self: List<a>, elem: a) -> List<a> {
  [elem, ..self]
}

test push_1() {
  push([], 0) == [0]
}

test push_2() {
  push([2, 3], 1) == [1, 2, 3]
}

/// Construct a list of a integer from a given range.
///
/// ```aiken
/// list.range(0, 3) == [0, 1, 2, 3]
/// list.range(-1, 1) == [-1, 0, 1]
/// ```
pub fn range(from: Int, to: Int) -> List<Int> {
  if from > to {
    []
  } else {
    [from, ..range(from + 1, to)]
  }
}

test range_1() {
  range(0, 3) == [0, 1, 2, 3]
}

test range_2() {
  range(-1, 1) == [-1, 0, 1]
}

/// Construct a list filled with n copies of a value.
///
/// ```aiken
/// list.repeat("na", 3) == ["na", "na", "na"]
/// ```
pub fn repeat(elem: a, n_times: Int) -> List<a> {
  if n_times <= 0 {
    []
  } else {
    [elem, ..repeat(elem, n_times - 1)]
  }
}

test repeat_1() {
  repeat(42, 0) == []
}

test repeat_2() {
  repeat(14, 3) == [14, 14, 14]
}

// ## Inspecting

/// Determine if all elements of the list satisfy the given predicate.
///
/// Note: an empty list always satisfies the predicate.
///
/// ```aiken
/// list.all([], fn(n) { n > 0 }) == True
/// list.all([1, 2, 3], fn(n) { n > 0 }) == True
/// list.all([1, 2, 3], fn(n) { n == 2 }) == False
/// ```
pub fn all(self: List<a>, predicate: fn(a) -> Bool) -> Bool {
  when self is {
    [] -> True
    [x, ..xs] -> predicate(x) && all(xs, predicate)
  }
}

test all_1() {
  all([1, 2, 3], fn(n) { n > 0 }) == True
}

test all_2() {
  all([1, 2, 3], fn(n) { n > 42 }) == False
}

test all_3() {
  all([], fn(n) { n == 42 }) == True
}

/// Determine if at least one element of the list satisfies the given predicate.
///
/// Note: an empty list never satisfies the predicate.
///
/// ```aiken
/// list.any([], fn(n) { n > 2 }) == False
/// list.any([1, 2, 3], fn(n) { n > 0 }) == True
/// list.any([1, 2, 3], fn(n) { n == 2 }) == True
/// list.any([1, 2, 3], fn(n) { n < 0 }) == False
/// ```
pub fn any(self: List<a>, predicate: fn(a) -> Bool) -> Bool {
  when self is {
    [] -> False
    [x, ..xs] -> predicate(x) || any(xs, predicate)
  }
}

test any_1() {
  any([1, 2, 3], fn(n) { n > 0 }) == True
}

test any_2() {
  any([1, 2, 3], fn(n) { n > 42 }) == False
}

test any_3() {
  any([], fn(n) { n == 42 }) == False
}

/// Return Some(item) at the index or None if the index is out of range. The index is 0-based.
///
/// ```aiken
/// list.at([1, 2, 3], 1) == Some(2)
/// list.at([1, 2, 3], 42) == None
/// ```
pub fn at(self: List<a>, index: Int) -> Option<a> {
  if index < 0 {
    None
  } else {
    do_at(self, index)
  }
}

fn do_at(self: List<a>, index: Int) -> Option<a> {
  when self is {
    [] -> None
    [x, ..xs] ->
      if index == 0 {
        Some(x)
      } else {
        do_at(xs, index - 1)
      }
  }
}

test at_1() {
  at([1, 2, 3], -1) == None
}

test at_2() {
  at([], 0) == None
}

test at_3() {
  at([1, 2, 3], 3) == None
}

test at_4() {
  at([1], 0) == Some(1)
}

test at_5() {
  at([1, 2, 3], 2) == Some(3)
}

/// Count how many items in the list satisfy the given predicate.
///
/// ```aiken
/// list.count([], fn(a) { a > 2}) == 0
/// list.count([1, 2, 3], fn(a) { n > 0 }) == 3
/// list.count([1, 2, 3], fn(a) { n >= 2 }) == 2
/// list.count([1, 2, 3], fn(a) { n > 5 }) == 0
/// ```
pub fn count(self: List<a>, predicate: fn(a) -> Bool) -> Int {
  foldr(
    self,
    0,
    fn(item, total) {
      if predicate(item) {
        total + 1
      } else {
        total
      }
    },
  )
}

test count_empty() {
  count([], fn(a) { a > 2 }) == 0
}

test count_all() {
  count([1, 2, 3], fn(a) { a > 0 }) == 3
}

test count_some() {
  count([1, 2, 3], fn(a) { a >= 2 }) == 2
}

test count_none() {
  count([1, 2, 3], fn(a) { a > 5 }) == 0
}

/// Find the first element satisfying the given predicate, if any.
///
/// ```aiken
/// list.find([1, 2, 3], fn(x) { x == 2 }) == Some(2)
/// list.find([4, 5, 6], fn(x) { x == 2 }) == None
/// ```
pub fn find(self: List<a>, predicate: fn(a) -> Bool) -> Option<a> {
  when self is {
    [] -> None
    [x, ..xs] ->
      if predicate(x) {
        Some(x)
      } else {
        find(xs, predicate)
      }
  }
}

test find_1() {
  find([1, 2, 3], fn(x) { x == 1 }) == Some(1)
}

test find_2() {
  find([1, 2, 3], fn(x) { x > 42 }) == None
}

test find_3() {
  find([], fn(_) { True }) == None
}

/// Like [`find`](#find), but maps the found element to something else. This
/// provides an efficient way to access and transform an element in a list.
///
/// ```aiken
/// list.find_map(["a", "bb", "ccc"], fn(x) {
///   let len = bytearray.length(x)
///   if len > 1 {
///     Some(len)
///   } else {
///     None
///   }
/// })
pub fn find_map(
  self: List<a>,
  predicate: fn(a) -> Option<result>,
) -> Option<result> {
  when self is {
    [] -> None
    [x, ..xs] -> {
      let result = predicate(x)
      if result != None {
        result
      } else {
        find_map(xs, predicate)
      }
    }
  }
}

test find_map_1() {
  find_map(
    [1, 2, 3],
    fn(x) {
      if x == 1 {
        Some(x - 1)
      } else {
        None
      }
    },
  ) == Some(0)
}

test find_map_2() {
  find_map(
    [1, 2, 3],
    fn(x) {
      if x > 42 {
        Some(x)
      } else {
        None
      }
    },
  ) == None
}

test find_map_3() {
  find_map([], fn(_) { Some(True) }) == None
}

/// Figures out whether a list contain the given element.
///
/// ```aiken
/// list.has([1, 2, 3], 2) == True
/// list.has([1, 2, 3], 14) == False
/// list.has([], 14) == False
/// ```
pub fn has(self: List<a>, elem: a) -> Bool {
  when self is {
    [] -> False
    [x, ..xs] ->
      if x == elem {
        True
      } else {
        has(xs, elem)
      }
  }
}

test has_1() {
  has([1, 2, 3], 1) == True
}

test has_2() {
  has([1, 2, 3], 14) == False
}

test has_3() {
  has([], 14) == False
}

/// Get the first element of a list
///
/// ```aiken
/// list.head([1, 2, 3]) == Some(1)
/// list.head([]) == None
/// ```
pub fn head(self: List<a>) -> Option<a> {
  when self is {
    [] -> None
    _ -> Some(builtin.head_list(self))
  }
}

test head_1() {
  head([1, 2, 3]) == Some(1)
}

test head_2() {
  head([]) == None
}

/// Checks whether a list is empty.
///
/// ```aiken
/// list.is_empty([]) == True
/// list.is_empty([1, 2, 3]) == False
/// ```
pub fn is_empty(self: List<a>) -> Bool {
  when self is {
    [] -> True
    _ -> False
  }
}

test is_empty_1() {
  is_empty([]) == True
}

test is_empty_2() {
  is_empty([1, 2, 3]) == False
}

/// Gets the index of an element of a list, if any. Otherwise, returns None.
///
/// ```aiken
/// list.index_of([1, 5, 2], 2) == Some(2)
/// list.index_of([1, 7, 3], 4) == None
/// list.index_of([1, 0, 9, 6], 6) == 3
/// list.index_of([], 6) == None
/// ```
pub fn index_of(self: List<a>, elem: a) -> Option<Int> {
  do_index_of(self, elem, 0)
}

fn do_index_of(self: List<a>, elem: a, i: Int) -> Option<Int> {
  when self is {
    [] -> None
    [x, ..xs] ->
      if x == elem {
        Some(i)
      } else {
        do_index_of(xs, elem, i + 1)
      }
  }
}

test index_of_1() {
  index_of([1, 5, 2], 2) == Some(2)
}

test index_of_2() {
  index_of([1, 7, 3], 4) == None
}

test index_of_3() {
  index_of([1, 0, 9, 6], 6) == Some(3)
}

test index_of_4() {
  index_of([], 6) == None
}

/// Get the last in the given list, if any.
///
/// ```aiken
/// list.last([]) == None
/// list.last([1, 2, 3]) == Some(3)
/// ```
pub fn last(self: List<a>) -> Option<a> {
  when self is {
    [] -> None
    [x] -> Some(x)
    [_, ..xs] -> last(xs)
  }
}

test last_1() {
  last([]) == None
}

test last_2() {
  last([1]) == Some(1)
}

test last_3() {
  last([1, 2, 3, 4]) == Some(4)
}

/// Get the number of elements in the given list.
///
/// ```aiken
/// list.length([]) == 0
/// list.length([1, 2, 3]) == 3
/// ```
pub fn length(self: List<a>) -> Int {
  when self is {
    [] -> 0
    [_, ..xs] -> 1 + length(xs)
  }
}

test length_1() {
  length([]) == 0
}

test length_2() {
  length([1, 2, 3]) == 3
}

// ## Modifying

// ### Extracting

/// Remove the first occurrence of the given element from the list.
///
/// ```aiken
/// list.delete([1, 2, 3, 1], 1) == [2, 3, 1]
/// list.delete([1, 2, 3], 14) == [1, 2, 3]
/// ```
pub fn delete(self: List<a>, elem: a) -> List<a> {
  when self is {
    [] -> []
    [x, ..xs] ->
      if x == elem {
        xs
      } else {
        [x, ..delete(xs, elem)]
      }
  }
}

test delete_1() {
  delete([], 42) == []
}

test delete_2() {
  delete([1, 2, 3, 1], 1) == [2, 3, 1]
}

test delete_3() {
  delete([1, 2, 3], 14) == [1, 2, 3]
}

test delete_4() {
  delete([2], 2) == []
}

/// Drop the first `n` elements of a list.
///
/// ```aiken
/// list.drop([1, 2, 3], 2) == [3]
/// list.drop([], 42) == []
/// list.drop([1, 2, 3], 42) == []
/// ```
pub fn drop(self: List<a>, n: Int) -> List<a> {
  if n <= 0 {
    self
  } else {
    when self is {
      [] -> []
      [_x, ..xs] -> drop(xs, n - 1)
    }
  }
}

test drop_1() {
  drop([], 42) == []
}

test drop_2() {
  drop([1, 2, 3], 2) == [3]
}

/// Returns the suffix of the given list after removing all elements that satisfy the predicate.
///
/// ```aiken
/// list.drop_while([1, 2, 3], fn(x) { x < 2 }) == [2, 3]
/// list.drop_while([], fn(x) { x > 2 }) == []
/// list.drop_while([1, 2, 3], fn(x) { x == 3 }) == [1, 2, 3]
/// ```
pub fn drop_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {
  when self is {
    [] -> []
    [x, ..xs] ->
      if predicate(x) {
        drop_while(xs, predicate)
      } else {
        self
      }
  }
}

test drop_while_1() {
  drop_while([], fn(x) { x > 2 }) == []
}

test drop_while_2() {
  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  drop_while(xs, fn(x) { x > 5 }) == [5, 4, 3, 2, 1]
}

test drop_while_3() {
  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  drop_while(xs, fn(x) { x == 42 }) == xs
}

test drop_while_4() {
  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  drop_while(xs, fn(x) { x < 42 }) == []
}

/// Produce a list of elements that satisfy a predicate.
///
/// ```aiken
/// list.filter([1, 2, 3], fn(x) { x >= 2 }) == [2, 3]
/// list.filter([], fn(x) { x > 2 }) == []
/// list.filter([1, 2, 3], fn(x) { x == 3 }) == [3]
/// ```
pub fn filter(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {
  when self is {
    [] -> []
    [x, ..xs] ->
      if predicate(x) {
        [x, ..filter(xs, predicate)]
      } else {
        filter(xs, predicate)
      }
  }
}

test filter_1() {
  filter([], fn(x) { x > 0 }) == []
}

test filter_2() {
  let xs = [1, 2, 3, 4, 5, 6]
  filter(xs, fn(x) { builtin.mod_integer(x, 2) == 0 }) == [2, 4, 6]
}

test filter_3() {
  let filter_foldr =
    fn(xs, f) {
      foldr(
        xs,
        [],
        fn(x, ys) {
          if f(x) {
            [x, ..ys]
          } else {
            ys
          }
        },
      )
    }

  let is_odd =
    fn(n) { builtin.mod_integer(n, 2) != 0 }

  filter_foldr([1, 2, 3], is_odd) == filter([1, 2, 3], is_odd)
}

/// Produce a list of transformed elements that satisfy a predicate.
///
/// ```aiken
/// let transform = fn(x) { if x % 2 == 0 { None } else { Some(3*x) } }
/// list.filter_map([1, 2, 3], transform) == [3, 9]
/// ```
pub fn filter_map(self: List<a>, predicate: fn(a) -> Option<b>) -> List<b> {
  when self is {
    [] -> []
    [x, ..xs] ->
      when predicate(x) is {
        None -> filter_map(xs, predicate)
        Some(y) -> [y, ..filter_map(xs, predicate)]
      }
  }
}

test filter_map_1() {
  filter_map([], fn(_) { Some(42) }) == []
}

test filter_map_2() {
  filter_map(
    [1, 2, 3, 4, 5, 6],
    fn(x) {
      if builtin.mod_integer(x, 2) != 0 {
        Some(3 * x)
      } else {
        None
      }
    },
  ) == [3, 9, 15]
}

/// Return all elements except the last one.
///
/// ```aiken
/// list.init([]) == None
/// list.init([1, 2, 3]) == Some([1, 2])
/// ```
pub fn init(self: List<a>) -> Option<List<a>> {
  when self is {
    [] -> None
    _ -> Some(do_init(self))
  }
}

fn do_init(self: List<a>) -> List<a> {
  when self is {
    [] -> fail @"unreachable"
    [_] -> []
    [x, ..xs] -> [x, ..do_init(xs)]
  }
}

test init_1() {
  init([]) == None
}

test init_2() {
  init([1]) == Some([])
}

test init_3() {
  init([1, 2, 3, 4]) == Some([1, 2, 3])
}

/// Returns a tuple with all elements that satisfy the predicate at first
/// element, and the rest as second element.
///
/// ```aiken
/// list.partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])
/// ```
pub fn partition(self: List<a>, predicate: fn(a) -> Bool) -> (List<a>, List<a>) {
  when self is {
    [] -> ([], [])
    [x, ..xs] -> {
      let (left, right) = partition(xs, predicate)
      if predicate(x) {
        ([x, ..left], right)
      } else {
        (left, [x, ..right])
      }
    }
  }
}

test partition_1() {
  partition([], fn(x) { x > 2 }) == ([], [])
}

test partition_2() {
  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  partition(xs, fn(x) { x > 5 }) == ([10, 9, 8, 7, 6], [5, 4, 3, 2, 1])
}

test partition_3() {
  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  partition(xs, fn(x) { x == 42 }) == ([], xs)
}

test partition_4() {
  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  partition(xs, fn(x) { x < 42 }) == (xs, [])
}

test partition_5() {
  partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])
}

/// Extract a sublist from the given list using 0-based indexes. Negative
/// indexes wrap over, so `-1` refers to the last element of the list.
///
/// ```aiken
/// list.slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]
/// list.slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]
/// list.slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]
/// ```
pub fn slice(self: List<a>, from: Int, to: Int) -> List<a> {
  let (i, l) =
    if from >= 0 {
      (from, None)
    } else {
      let l = length(self)
      (l + from, Some(l))
    }

  let j =
    if to >= 0 {
      to - i + 1
    } else {
      when l is {
        Some(l) -> l + to - i + 1
        None -> length(self) + to - i + 1
      }
    }

  self
    |> drop(i)
    |> take(j)
}

test slice_1() {
  slice([1, 2, 3], 0, 2) == [1, 2, 3]
}

test slice_2() {
  slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]
}

test slice_3() {
  slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]
}

test slice_4() {
  slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]
}

test slice_5() {
  slice([1, 2, 3, 4, 5, 6], from: -4, to: -3) == [3, 4]
}

test slice_6() {
  slice([1, 2, 3, 4, 5, 6], from: -2, to: 1) == []
}

/// Cut a list in two, such that the first list contains the given number of /
/// elements and the second list contains the rest.
///
/// Fundamentally equivalent to (but more efficient):
///
/// ```aiken
/// // span(xs, n) == (take(xs, n), drop(xs, n))
/// span([1, 2, 3, 4, 5], 3) == ([1, 2, 3], [4, 5])
/// ```
pub fn span(self: List<a>, n: Int) -> (List<a>, List<a>) {
  when self is {
    [] -> ([], [])
    [x, ..xs] ->
      if n <= 0 {
        ([], self)
      } else {
        let (left, right) = span(xs, n - 1)
        ([x, ..left], right)
      }
  }
}

test span_1() {
  span([], 2) == ([], [])
}

test span_2() {
  span([1, 2, 3], 2) == ([1, 2], [3])
}

test span_3() {
  span([1, 2, 3], -1) == ([], [1, 2, 3])
}

test span_4() {
  span([1, 2, 3], 42) == ([1, 2, 3], [])
}

/// Get elements of a list after the first one, if any.
///
/// ```aiken
/// list.tail([]) == None
/// list.tail([1, 2, 3]) == Some([2, 3])
/// ```
pub fn tail(self: List<a>) -> Option<List<a>> {
  when self is {
    [] -> None
    [_, ..xs] -> Some(xs)
  }
}

test tail_1() {
  tail([1, 2, 3]) == Some([2, 3])
}

test tail_2() {
  tail([]) == None
}

/// Get the first `n` elements of a list.
///
/// ```aiken
/// list.take([1, 2, 3], 2) == [1, 2]
/// list.take([1, 2, 3], 14) == [1, 2, 3]
/// ```
pub fn take(self: List<a>, n: Int) -> List<a> {
  if n <= 0 {
    []
  } else {
    when self is {
      [] -> []
      [x, ..xs] -> [x, ..take(xs, n - 1)]
    }
  }
}

test take_1() {
  take([], 42) == []
}

test take_2() {
  take([1, 2, 3], 2) == [1, 2]
}

/// Returns the longest prefix of the given list where all elements satisfy the predicate.
///
/// ```aiken
/// list.take_while([1, 2, 3], fn(x) { x > 2 }) == []
/// list.take_while([1, 2, 3], fn(x) { x < 2 }) == [1]
/// ```
pub fn take_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {
  when self is {
    [] -> []
    [x, ..xs] ->
      if predicate(x) {
        [x, ..take_while(xs, predicate)]
      } else {
        []
      }
  }
}

test take_while_1() {
  take_while([], fn(x) { x > 2 }) == []
}

test take_while_2() {
  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  take_while(xs, fn(x) { x > 5 }) == [10, 9, 8, 7, 6]
}

test take_while_3() {
  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  take_while(xs, fn(x) { x == 42 }) == []
}

test take_while_4() {
  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  take_while(xs, fn(x) { x < 42 }) == xs
}

/// Removes duplicate elements from a list.
///
/// ```aiken
/// list.unique([1, 2, 3, 1]) == [1, 2, 3]
/// ```
pub fn unique(self: List<a>) -> List<a> {
  when self is {
    [] -> []
    [x, ..xs] -> [x, ..unique(filter(xs, fn(y) { y != x }))]
  }
}

test unique_1() {
  unique([]) == []
}

test unique_2() {
  let xs = [1, 2, 3, 1, 1, 3, 4, 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 10, 9]
  unique(xs) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
}

// ### Mapping

/// Map elements of a list into a new list and flatten the result.
///
/// ```aiken
/// list.flat_map([1, 2, 3], fn(a) { [a, 2*a] }) == [1, 2, 2, 4, 3, 6]
/// ```
pub fn flat_map(self: List<a>, with: fn(a) -> List<b>) -> List<b> {
  foldr(self, [], fn(x, xs) { concat(with(x), xs) })
}

test flat_map_1() {
  flat_map([], fn(a) { [a] }) == []
}

test flat_map_2() {
  flat_map([1, 2, 3], fn(a) { [a, a] }) == [1, 1, 2, 2, 3, 3]
}

/// Perform an action for each element of a list.
///
/// ```aiken
/// list.for_each(labels, do: fn(lbl) { trace lbl Void })
/// ```
pub fn for_each(self: List<a>, do: fn(a) -> Void) -> Void {
  foldr(self, Void, fn(x, _) { do(x) })
}

test for_each_1() {
  for_each(
    [@"hello", @"world"],
    do: fn(lbl) {
      trace lbl
      Void
    },
  )
}

/// List [`map`](#map) but provides the position (0-based) of the elements while iterating.
///
/// ```aiken
/// list.indexed_map([1, 2, 3], fn(i, x) { i + x }) == [1, 3, 5]
/// ```
pub fn indexed_map(self: List<a>, with: fn(Int, a) -> result) -> List<result> {
  do_indexed_map(0, self, with)
}

fn do_indexed_map(
  n: Int,
  self: List<a>,
  with: fn(Int, a) -> result,
) -> List<result> {
  when self is {
    [] -> []
    [x, ..xs] -> [with(n, x), ..do_indexed_map(n + 1, xs, with)]
  }
}

test indexed_map_1() {
  indexed_map([], fn(i, _n) { i }) == []
}

test indexed_map_2() {
  indexed_map(
    [4, 8, 13, 2],
    fn(i, n) {
      if n == 8 {
        n
      } else {
        i
      }
    },
  ) == [0, 8, 2, 3]
}

/// Apply a function to each element of a list.
///
/// ```aiken
/// list.map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]
/// ```
pub fn map(self: List<a>, with: fn(a) -> result) -> List<result> {
  when self is {
    [] -> []
    [x, ..xs] -> [with(x), ..map(xs, with)]
  }
}

test map_1() {
  map([], fn(n) { n + 1 }) == []
}

test map_2() {
  map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]
}

/// Apply a function of two arguments, combining elements from two lists.
///
/// Note: if one list is longer, the extra elements are dropped.
///
/// ```aiken
/// list.map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]
/// ```
pub fn map2(
  self: List<a>,
  bs: List<b>,
  with: fn(a, b) -> result,
) -> List<result> {
  when self is {
    [] -> []
    [x, ..xs] ->
      when bs is {
        [] -> []
        [y, ..ys] -> [with(x, y), ..map2(xs, ys, with)]
      }
  }
}

test map2_1() {
  map2([], [1, 2, 3], fn(a, b) { a + b }) == []
}

test map2_2() {
  map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]
}

test map2_3() {
  map2([42], [1, 2, 3], fn(_a, b) { Some(b) }) == [Some(1)]
}

/// Apply a function of three arguments, combining elements from three lists.
///
/// Note: if one list is longer, the extra elements are dropped.
///
/// ```aiken
/// list.map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]
/// ```
pub fn map3(
  self: List<a>,
  bs: List<b>,
  cs: List<c>,
  with: fn(a, b, c) -> result,
) -> List<result> {
  when self is {
    [] -> []
    [x, ..xs] ->
      when bs is {
        [] -> []
        [y, ..ys] ->
          when cs is {
            [] -> []
            [z, ..zs] -> [with(x, y, z), ..map3(xs, ys, zs, with)]
          }
      }
  }
}

test map3_1() {
  map3([], [], [1, 2, 3], fn(a, b, c) { a + b + c }) == []
}

test map3_2() {
  map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]
}

/// Return the list with its elements in the reserve order.
///
/// ```aiken
/// list.reverse([1, 2, 3]) == [3, 2, 1]
/// ```
pub fn reverse(self: List<a>) -> List<a> {
  foldl(self, [], fn(x, xs) { [x, ..xs] })
}

test reverse_1() {
  reverse([]) == []
}

test reverse_2() {
  reverse([1, 2, 3]) == [3, 2, 1]
}

/// Sort a list in ascending order using the given comparison function.
///
/// ```aiken
/// use aiken/int
///
/// sort([3, 1, 4, 0, 2], int.compare) == [0, 1, 2, 3, 4]
/// sort([1, 2, 3], int.compare) == [1, 2, 3]
/// ```
pub fn sort(self: List<a>, compare: fn(a, a) -> Ordering) -> List<a> {
  when self is {
    [] -> []
    [x, ..xs] -> insert(sort(xs, compare), x, compare)
  }
}

fn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {
  when self is {
    [] -> [e]
    [x, ..xs] ->
      if compare(e, x) == Less {
        [e, ..self]
      } else {
        [x, ..insert(xs, e, compare)]
      }
  }
}

test sort_1() {
  let xs = [6, 7, 5, 4, 1, 3, 9, 8, 0, 2]
  sort(xs, int.compare) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}

test sort_2() {
  let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  sort(xs, int.compare) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}

test sort_3() {
  let xs = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
  sort(xs, int.compare) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}

test sort_4() {
  sort([], int.compare) == []
}

/// Decompose a list of tuples into a tuple of lists.
///
/// ```
/// list.unzip([(1, "a"), (2, "b")]) == ([1, 2], ["a", "b"])
/// ```
pub fn unzip(self: List<(a, b)>) -> (List<a>, List<b>) {
  when self is {
    [] -> ([], [])
    [(a, b), ..xs] -> {
      let (a_tail, b_tail) = unzip(xs)
      ([a, ..a_tail], [b, ..b_tail])
    }
  }
}

test unzip_1() {
  unzip([]) == ([], [])
}

test unzip_2() {
  unzip([(1, "a"), (2, "b")]) == ([1, 2], ["a", "b"])
}

// ## Combining

/// Merge two lists together.
///
/// ```aiken
/// list.concat([], []) == []
/// list.concat([], [1, 2, 3]) == [1, 2, 3]
/// list.concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]
/// ```
pub fn concat(left: List<a>, right: List<a>) -> List<a> {
  when left is {
    [] -> right
    [x, ..xs] -> [x, ..concat(xs, right)]
  }
}

test concat_1() {
  concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]
}

test concat_2() {
  concat([1, 2, 3], []) == [1, 2, 3]
}

test concat_3() {
  concat([], [1, 2, 3]) == [1, 2, 3]
}

/// Remove the first occurrence of each element of the second list from the first one.
///
/// ```
/// list.difference(["h", "e", "l", "l", "o"], ["l", "e", "l"]) == ["h", "o"]
/// list.difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]
/// list.difference([1, 2, 3], []) == [1, 2, 3]
/// ```
pub fn difference(self: List<a>, with: List<a>) -> List<a> {
  when with is {
    [] -> self
    [x, ..xs] -> difference(delete(self, x), xs)
  }
}

test difference_1() {
  difference(["h", "e", "l", "l", "o"], ["l", "e", "l"]) == ["h", "o"]
}

test difference_2() {
  difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]
}

test difference_3() {
  difference([1, 2, 3], []) == [1, 2, 3]
}

test difference_4() {
  difference([], [1, 2, 3]) == []
}

/// Combine two lists together.
///
/// Note: if one list is longer, the extra elements are dropped.
///
/// ```aiken
/// list.zip([1, 2], ["a", "b", "c"]) == [(1, "a"), (2, "b")]
/// ```
pub fn zip(self: List<a>, bs: List<b>) -> List<(a, b)> {
  when self is {
    [] -> []
    [x, ..xs] ->
      when bs is {
        [] -> []
        [y, ..ys] -> [(x, y), ..zip(xs, ys)]
      }
  }
}

test zip_1() {
  zip([], [1, 2, 3]) == []
}

test zip_2() {
  zip([1, 2, 3], []) == []
}

test zip_3() {
  zip([1, 2], ["a", "b", "c"]) == [(1, "a"), (2, "b")]
}

// ## Transforming

/// Reduce a list from left to right.
///
/// ```aiken
/// list.foldl([1, 2, 3], 0, fn(n, total) { n + total }) == 6
/// list.foldl([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [3, 2, 1]
/// ```
pub fn foldl(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {
  when self is {
    [] -> zero
    [x, ..xs] -> foldl(xs, with(x, zero), with)
  }
}

/// A function callback to accumulate two returned values at once. See also [`foldl2`](#foldl2) and [`foldr2`](#foldr2) about usage.
pub type Fold2<a, b, result> =
  fn(a, b) -> result

/// Reduce a list from left to right, while accumulating two results. This is
/// faster (albeit equivalent) than accumulating both results in a `Pair` or tuple.
///
/// > [!TIP]
/// > Using [`backpassing`](https://aiken-lang.org/language-tour/functions#backpassing-) to ease readability is a good idea.
///
/// ```aiken
/// let len, sum <-
///    foldl2(
///      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
///      0,
///      0,
///      fn(n, len, sum, return) { return(len + 1, sum + n) },
///    )
///
/// and {
///   len == 10,
///   sum == 55,
/// }
/// ```
pub fn foldl2(
  self: List<elem>,
  zero_a: a,
  zero_b: b,
  with: fn(elem, a, b, Fold2<a, b, result>) -> result,
  return: Fold2<a, b, result>,
) -> result {
  when self is {
    [] -> return(zero_a, zero_b)
    [x, ..xs] -> {
      let a, b <- with(x, zero_a, zero_b)
      foldl2(xs, a, b, with, return)
    }
  }
}

test foldl2_optimized() {
  let
    len,
    sum,
  <-
    foldl2(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      0,
      0,
      fn(n, len, sum, return) { return(len + 1, sum + n) },
    )

  and {
    len == 10,
    sum == 55,
  }
}

test foldl2_classic() {
  let (len, sum) =
    foldl(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      (0, 0),
      fn(n, (len, sum)) { (len + 1, sum + n) },
    )

  and {
    len == 10,
    sum == 55,
  }
}

type Foo {
  Foo(Int, Int)
}

test foldl2_pair() {
  let Pair(len, sum) =
    foldl(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      Pair(0, 0),
      fn(n, Pair(len, sum)) { Pair(len + 1, sum + n) },
    )

  and {
    len == 10,
    sum == 55,
  }
}

test foldl2_foo() {
  let Foo(len, sum) =
    foldl(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      Foo(0, 0),
      fn(n, Foo(len, sum)) { Foo(len + 1, sum + n) },
    )

  and {
    len == 10,
    sum == 55,
  }
}

test foldl_1() {
  foldl([], 0, fn(_, _) { 1 }) == 0
}

test foldl_2() {
  foldl([1, 2, 3, 4, 5], 0, fn(n, total) { n + total }) == 15
}

test foldl_3() {
  foldl([1, 2, 3, 4], [], fn(x, xs) { [x, ..xs] }) == [4, 3, 2, 1]
}

/// Reduce a list from right to left.
///
/// ```aiken
/// list.foldr([1, 2, 3], 0, fn(n, total) { n + total }) == 6
/// list.foldr([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [1, 2, 3]
/// ```
pub fn foldr(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {
  when self is {
    [] -> zero
    [x, ..xs] -> with(x, foldr(xs, zero, with))
  }
}

test foldr_1() {
  foldr([1, 2, 3, 4, 5], 0, fn(n, total) { n + total }) == 15
}

test foldr_2() {
  foldr(
    [1, 2, 3],
    "",
    fn(n, _str) {
      if builtin.mod_integer(n, 2) == 0 {
        "foo"
      } else {
        "bar"
      }
    },
  ) == "bar"
}

test foldr_3() {
  foldr([1, 2, 3, 4], [], fn(x, xs) { [x, ..xs] }) == [1, 2, 3, 4]
}

/// Reduce a list from right to left, while accumulating two results. This is
/// faster (albeit equivalent) than accumulating both results in a `Pair` or tuple.
///
/// > [!TIP]
/// > Using [`backpassing`](https://aiken-lang.org/language-tour/functions#backpassing-) to ease readability is a good idea.
///
/// ```aiken
/// let len, sum <-
///    foldr2(
///      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
///      0,
///      0,
///      fn(n, len, sum, return) { return(len + 1, sum + n) },
///    )
///
/// and {
///   len == 10,
///   sum == 55,
/// }
/// ```
pub fn foldr2(
  self: List<elem>,
  zero_a: a,
  zero_b: b,
  with: fn(elem, a, b, Fold2<a, b, result>) -> result,
  return: Fold2<a, b, result>,
) -> result {
  do_foldr2(self, with, return)(zero_a, zero_b)
}

fn do_foldr2(
  self: List<elem>,
  with: fn(elem, a, b, Fold2<a, b, result>) -> result,
  return: Fold2<a, b, result>,
) -> Fold2<a, b, result> {
  when self is {
    [] -> return
    [x, ..xs] -> do_foldr2(xs, with, fn(a, b) { with(x, a, b, return) })
  }
}

test foldr2_optimized() {
  let
    len,
    sum,
  <-
    foldr2(
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      0,
      0,
      fn(n, len, sum, return) { return(len + 1, sum + n) },
    )

  and {
    len == 10,
    sum == 55,
  }
}

/// Like [`foldr`](#foldr), but also provides the position (0-based) of the elements when iterating.
///
/// ```aiken
/// let group = fn(i, x, xs) { [(i, x), ..xs] }
/// list.indexed_foldr(["a", "b", "c"], [], group) == [
///   (0, "a"),
///   (1, "b"),
///   (2, "c")
/// ]
/// ```
pub fn indexed_foldr(
  self: List<a>,
  zero: result,
  with: fn(Int, a, result) -> result,
) -> result {
  do_indexed_foldr(0, self, zero, with)
}

fn do_indexed_foldr(
  n: Int,
  self: List<a>,
  zero: result,
  with: fn(Int, a, result) -> result,
) -> result {
  when self is {
    [] -> zero
    [x, ..xs] -> with(n, x, do_indexed_foldr(n + 1, xs, zero, with))
  }
}

test indexed_foldr_1() {
  indexed_foldr([], 0, fn(i, x, xs) { i + x + xs }) == 0
}

test indexed_foldr_2() {
  let letters = ["a", "b", "c"]
  indexed_foldr(letters, [], fn(i, x, xs) { [(i, x), ..xs] }) == [
    (0, "a"), (1, "b"), (2, "c"),
  ]
}

/// Reduce a list from left to right using the accumulator as left operand.
/// Said differently, this is [`foldl`](#foldl) with callback arguments swapped.
///
/// ```aiken
/// list.reduce([#[1], #[2], #[3]], #[0], bytearray.concat) == #[0, 1, 2, 3]
/// list.reduce([True, False, True], False, fn(b, a) { or { b, a } }) == True
/// ```
pub fn reduce(self: List<a>, zero: b, with: fn(b, a) -> b) -> b {
  foldl(self, zero, flip(with))
}

test reduce_1() {
  reduce([], 0, fn(n, total) { n + total }) == 0
}

test reduce_2() {
  reduce([1, 2, 3], 0, fn(n, total) { n + total }) == 6
}

test reduce_3() {
  reduce([True, False, True], False, fn(left, right) { left || right }) == True
}

test reduce_4() {
  reduce(
    [#[1], #[2], #[3]],
    #[9],
    fn(left, right) { bytearray.concat(left, right) },
  ) == #[9, 1, 2, 3]
}



================================================
FILE: lib/aiken/collection/pairs.ak
================================================
//// A module for working with associative lists (a.k.a `Pairs`).
////
//// While any function that works on `List` also work on `Pairs`, this module provides some extra helpers
//// that are specifically tailored to working with associative lists. Fundamentally, a `Pairs<k, v>` is
//// a type-alias to `List<Pair<k, v>>`.
////
//// > [!CAUTION]
//// >
//// > Unlike dictionnaries (a.k.a. [`Dict`](./dict.html#Dict), associative lists make no assumption
//// > about the ordering of elements within the list. As a result, lookup
//// > functions do traverse the entire list when invoked. They are also not _sets_,
//// > and thus allow for duplicate keys. This is reflected in the functions used
//// > to interact with them.

use aiken/builtin
use aiken/primitive/bytearray

// ## Inspecting

/// Get all values in the alist associated with a given key.
///
/// ```aiken
/// pairs.get_all([], "a") == []
/// pairs.get_all([Pair("a", 1)], "a") == [1]
/// pairs.get_all([Pair("a", 1), Pair("b", 2)], "a") == [1]
/// pairs.get_all([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == [1, 3]
/// ```
pub fn get_all(self: Pairs<key, value>, key k: key) -> List<value> {
  when self is {
    [] -> []
    [Pair(k2, v), ..rest] ->
      if k == k2 {
        [v, ..get_all(rest, k)]
      } else {
        get_all(rest, k)
      }
  }
}

test get_all_1() {
  get_all([], "a") == []
}

test get_all_2() {
  get_all([Pair("a", 1)], "a") == [1]
}

test get_all_3() {
  get_all([Pair("a", 1), Pair("b", 2)], "a") == [1]
}

test get_all_4() {
  get_all([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == [1, 3]
}

test get_all_5() {
  get_all([Pair("a", 1), Pair("b", 2), Pair("c", 3)], "d") == []
}

/// Get the value in the alist by its key.
/// If multiple values with the same key exist, only the first one is returned.
///
/// ```aiken
/// pairs.get_first([], "a") == None
/// pairs.get_first([Pair("a", 1)], "a") == Some(1)
/// pairs.get_first([Pair("a", 1), Pair("b", 2)], "a") == Some(1)
/// pairs.get_first([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == Some(1)
/// ```
pub fn get_first(self: Pairs<key, value>, key k: key) -> Option<value> {
  when self is {
    [] -> None
    [Pair(k2, v), ..rest] ->
      if k == k2 {
        Some(v)
      } else {
        get_first(rest, k)
      }
  }
}

test get_first_1() {
  get_first([], "a") == None
}

test get_first_2() {
  get_first([Pair("a", 1)], "a") == Some(1)
}

test get_first_3() {
  get_first([Pair("a", 1), Pair("b", 2)], "a") == Some(1)
}

test get_first_4() {
  get_first([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == Some(1)
}

test get_first_5() {
  get_first([Pair("a", 1), Pair("b", 2), Pair("c", 3)], "d") == None
}

/// Get the value in the alist by its key.
/// If multiple values with the same key exist, only the last one is returned.
///
/// ```aiken
/// pairs.get_last([], "a") == None
/// pairs.get_last([Pair("a", 1)], "a") == Some(1)
/// pairs.get_last([Pair("a", 1), Pair("b", 2)], "a") == Some(1)
/// pairs.get_last([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == Some(3)
/// ```
pub fn get_last(self: Pairs<key, value>, key k: key) -> Option<value> {
  when self is {
    [] -> None
    [Pair(k2, v), ..rest] ->
      if k == k2 {
        when get_last(rest, k) is {
          None -> Some(v)
          some -> some
        }
      } else {
        get_last(rest, k)
      }
  }
}

test get_last_1() {
  get_last([], "a") == None
}

test get_last_2() {
  get_last([Pair("a", 1)], "a") == Some(1)
}

test get_last_3() {
  get_last([Pair("a", 1), Pair("b", 2)], "a") == Some(1)
}

test get_last_4() {
  get_last([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == Some(3)
}

test get_last_5() {
  get_last([Pair("a", 1), Pair("b", 2), Pair("c", 3)], "d") == None
}

/// Finds all keys in the alist associated with a given value.
///
/// ```aiken
/// pairs.find_all([], 1) == []
/// pairs.find_all([Pair("a", 1)], 1) == ["a"]
/// pairs.find_all([Pair("a", 1), Pair("b", 2)], 1) == ["a"]
/// pairs.find_all([Pair("a", 1), Pair("b", 2), Pair("c", 1)], 1) == ["a", "c"]
/// ```
pub fn find_all(self: Pairs<key, value>, v: value) -> List<key> {
  when self is {
    [] -> []
    [Pair(k2, v2), ..rest] ->
      if v == v2 {
        [k2, ..find_all(rest, v)]
      } else {
        find_all(rest, v)
      }
  }
}

test find_all_1() {
  find_all([], "a") == []
}

test find_all_2() {
  find_all([Pair("a", 14)], 14) == ["a"]
}

test find_all_3() {
  find_all([Pair("a", 14)], 42) == []
}

test find_all_4() {
  find_all([Pair("a", 14), Pair("b", 42), Pair("c", 14)], 14) == ["a", "c"]
}

/// Finds the first key in the alist associated with a given value, if any.
///
/// ```aiken
/// pairs.find_first([], 1) == None
/// pairs.find_first([Pair("a", 1)], 1) == Some("a")
/// pairs.find_first([Pair("a", 1), Pair("b", 2)], 1) == Some("a")
/// pairs.find_first([Pair("a", 1), Pair("b", 2), Pair("c", 1)], 1) == Some("a")
/// ```
pub fn find_first(self: Pairs<key, value>, v: value) -> Option<key> {
  when self is {
    [] -> None
    [Pair(k2, v2), ..rest] ->
      if v == v2 {
        Some(k2)
      } else {
        find_first(rest, v)
      }
  }
}

test find_first_1() {
  find_first([], "a") == None
}

test find_first_2() {
  find_first([Pair("a", 14)], 14) == Some("a")
}

test find_first_3() {
  find_first([Pair("a", 14)], 42) == None
}

test find_first_4() {
  find_first([Pair("a", 14), Pair("b", 42), Pair("c", 14)], 14) == Some("a")
}

/// Finds the last key in the alist associated with a given value, if any.
///
/// ```aiken
/// pairs.find_last([], 1) == None
/// pairs.find_last([Pair("a", 1)], 1) == Some("a")
/// pairs.find_last([Pair("a", 1), Pair("b", 2)], 1) == Some("a")
/// pairs.find_last([Pair("a", 1), Pair("b", 2), Pair("c", 1)], 1) == Some("c")
/// ```
pub fn find_last(self: Pairs<key, value>, v: value) -> Option<key> {
  when self is {
    [] -> None
    [Pair(k2, v2), ..rest] ->
      if v == v2 {
        when find_last(rest, v) is {
          None -> Some(k2)
          some -> some
        }
      } else {
        find_last(rest, v)
      }
  }
}

test find_last_1() {
  find_last([], "a") == None
}

test find_last_2() {
  find_last([Pair("a", 14)], 14) == Some("a")
}

test find_last_3() {
  find_last([Pair("a", 14)], 42) == None
}

test find_last_4() {
  find_last([Pair("a", 14), Pair("b", 42), Pair("c", 14)], 14) == Some("c")
}

/// Check if a key exists in the pairs.
///
/// ```aiken
/// pairs.has_key([], "a") == False
/// pairs.has_key([Pair("a", 1)], "a") == True
/// pairs.has_key([Pair("a", 1), Pair("b", 2)], "a") == True
/// pairs.has_key([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == True
/// ```
pub fn has_key(self: Pairs<key, value>, k: key) -> Bool {
  when self is {
    [] -> False
    // || is lazy so this is fine
    [Pair(k2, _), ..rest] -> k == k2 || has_key(rest, k)
  }
}

test has_key_1() {
  !has_key([], "a")
}

test has_key_2() {
  has_key([Pair("a", 14)], "a")
}

test has_key_3() {
  !has_key([Pair("a", 14)], "b")
}

test has_key_4() {
  has_key([Pair("a", 14), Pair("b", 42)], "b")
}

test has_key_5() {
  has_key([Pair("a", 14), Pair("b", 42), Pair("a", 42)], "a")
}

/// Extract all the keys present in a given `Pairs`.
///
/// ```aiken
/// pairs.keys([]) == []
/// pairs.keys([Pair("a", 1)]) == ["a"]
/// pairs.keys([Pair("a", 1), Pair("b", 2)]) == ["a", "b"]
/// pairs.keys([Pair("a", 1), Pair("b", 2), Pair("a", 3)]) == ["a", "b", "a"]
/// ```
pub fn keys(self: Pairs<key, value>) -> List<key> {
  when self is {
    [] -> []
    [Pair(k, _), ..rest] -> [k, ..keys(rest)]
  }
}

test keys_1() {
  keys([]) == []
}

test keys_2() {
  keys([Pair("a", 0)]) == ["a"]
}

test keys_3() {
  keys([Pair("a", 0), Pair("b", 0)]) == ["a", "b"]
}

/// Extract all the values present in a given `Pairs`.
///
/// ```aiken
/// pairs.values([]) == []
/// pairs.values([Pair("a", 1)]) == [1]
/// pairs.values([Pair("a", 1), Pair("b", 2)]) == [1, 2]
/// pairs.values([Pair("a", 1), Pair("b", 2), Pair("a", 3)]) == [1, 2, 3]
/// ```
pub fn values(self: Pairs<key, value>) -> List<value> {
  when self is {
    [] -> []
    [Pair(_, v), ..rest] -> [v, ..values(rest)]
  }
}

test values_1() {
  values([]) == []
}

test values_2() {
  values([Pair("a", 1)]) == [1]
}

test values_3() {
  values([Pair("a", 1), Pair("b", 2)]) == [1, 2]
}

test values_4() {
  values([Pair("a", 1), Pair("b", 2), Pair("a", 3)]) == [1, 2, 3]
}

// ## Modifying

/// Remove all key-value pairs matching the key from the Pairs. If the key is not found, no changes are made.
///
/// ```aiken
/// pairs.delete_all([], "a") == []
/// pairs.delete_all([Pair("a", 1)], "a") == []
/// pairs.delete_all([Pair("a", 1), Pair("b", 2)], "a") == [Pair("b", 2)]
/// pairs.delete_all([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == [Pair("b", 2)]
/// ```
pub fn delete_all(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {
  when self is {
    [] -> []
    [Pair(k2, v2), ..rest] ->
      if k == k2 {
        delete_all(rest, k)
      } else {
        [Pair(k2, v2), ..delete_all(rest, k)]
      }
  }
}

test delete_all_1() {
  delete_all([], "a") == []
}

test delete_all_2() {
  delete_all([Pair("a", 14)], "a") == []
}

test delete_all_3() {
  let fixture = [Pair("a", 14)]
  delete_all(fixture, "b") == fixture
}

test delete_all_4() {
  let fixture = [Pair("a", 1), Pair("b", 2), Pair("a", 3)]
  delete_all(fixture, "a") == [Pair("b", 2)]
}

/// Remove a single key-value pair from the `Pairs`. If the key is not found, no changes are made.
/// Duplicate keys are not deleted. Only the **first** key found is deleted.
///
/// ```aiken
/// pairs.delete_first([], "a") == []
/// pairs.delete_first([Pair("a", 1)], "a") == []
/// pairs.delete_first([Pair("a", 1), Pair("b", 2)], "a") == [Pair("b", 2)]
/// pairs.delete_first([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == [Pair("b", 2), Pair("a", 3)]
/// ```
pub fn delete_first(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {
  when self is {
    [] -> []
    [Pair(k2, v2), ..rest] ->
      if k == k2 {
        rest
      } else {
        [Pair(k2, v2), ..delete_first(rest, k)]
      }
  }
}

test delete_first_1() {
  delete_first([], "a") == []
}

test delete_first_2() {
  delete_first([Pair("a", 14)], "a") == []
}

test delete_first_3() {
  let fixture = [Pair("a", 14)]
  delete_first(fixture, "b") == fixture
}

test delete_first_4() {
  let fixture = [Pair("a", 1), Pair("b", 2), Pair("a", 3)]
  delete_first(fixture, "a") == [Pair("b", 2), Pair("a", 3)]
}

/// Remove a single key-value pair from the Pairs. If the key is not found, no changes are made.
/// Duplicate keys are not deleted. Only the **last** key found is deleted.
///
/// ```aiken
/// pairs.delete_last([], "a") == []
/// pairs.delete_last([Pair("a", 1)], "a") == []
/// pairs.delete_last([Pair("a", 1), Pair("b", 2)], "a") == [Pair("b", 2)]
/// pairs.delete_last([Pair("a", 1), Pair("b", 2), Pair("a", 3)], "a") == [Pair("a", 1), Pair("b", 2)]
/// ```
pub fn delete_last(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {
  when self is {
    [] -> []
    [Pair(k2, v2), ..rest] ->
      if k == k2 {
        let tail = delete_last(rest, k)
        if tail == rest {
          rest
        } else {
          [Pair(k2, v2), ..tail]
        }
      } else {
        [Pair(k2, v2), ..delete_last(rest, k)]
      }
  }
}

test delete_last_1() {
  delete_last([], "a") == []
}

test delete_last_2() {
  delete_last([Pair("a", 14)], "a") == []
}

test delete_last_3() {
  let fixture = [Pair("a", 14)]
  delete_last(fixture, "b") == fixture
}

test delete_last_4() {
  let fixture = [Pair("a", 1), Pair("b", 2), Pair("a", 3)]
  delete_last(fixture, "a") == [Pair("a", 1), Pair("b", 2)]
}

/// Insert a value in the `Pairs` at a given key. If the key already exists,
/// the value is added in front.
///
/// > [!CAUTION]
/// > The list is only traversed up to the given key and the traversal
/// > stops as soon as a higher key is encountered. Said differently, the list
/// > is assumed to **be ordered by ascending keys**! If it is not, expect the
/// > unexpected.
///
/// ```aiken
/// use aiken/primitive/bytearray
///
/// let result =
///   []
///     |> pairs.insert_by_ascending_key(key: "foo", value: 1, compare: bytearray.compare)
///     |> pairs.insert_by_ascending_key(key: "bar", value: 2, compare: bytearray.compare)
///     |> pairs.insert_by_ascending_key(key: "foo", value: 3, compare: bytearray.compare)
///
/// result == [Pair("bar", 2), Pair("foo", 3), Pair("foo", 1)]
/// ```
pub fn insert_by_ascending_key(
  self: Pairs<key, value>,
  key k: key,
  value v: value,
  compare: fn(key, key) -> Ordering,
) -> Pairs<key, value> {
  when self is {
    [] -> [Pair(k, v)]
    [Pair(k2, v2), ..rest] ->
      if compare(k, k2) == Less {
        [Pair(k, v), ..self]
      } else {
        if k == k2 {
          [Pair(k, v), ..self]
        } else {
          [Pair(k2, v2), ..insert_by_ascending_key(rest, k, v, compare)]
        }
      }
  }
}

test insert_by_ascending_key_1() {
  let m =
    []
      |> insert_by_ascending_key("foo", 42, bytearray.compare)
      |> insert_by_ascending_key("foo", 14, bytearray.compare)

  m == [Pair("foo", 14), Pair("foo", 42)]
}

test insert_by_ascending_key_2() {
  let m =
    []
      |> insert_by_ascending_key("foo", 42, bytearray.compare)
      |> insert_by_ascending_key("bar", 14, bytearray.compare)
      |> insert_by_ascending_key("baz", 1337, bytearray.compare)

  m == [Pair("bar", 14), Pair("baz", 1337), Pair("foo", 42)]
}

/// Like [`insert_by_ascending_key`](#insert_by_ascending_key) but specifies
/// how to combine two values on a key conflict.
///
/// > [!CAUTION]
/// > The list is only traversed up to the given key and the traversal
/// > stops as soon as a higher key is encountered. Said differently, the list
/// > is assumed to **be ordered by ascending keys**! If it is not, expect the
/// > unexpected.
///
/// ```aiken
/// use aiken/primitive/bytearray
///
/// let add_integer = fn(x, y) { x + y }
///
/// let result =
///   []
///     |> pairs.insert_with_by_ascending_key(key: "foo", value: 1, compare: bytearray.compare, with: add_integer)
///     |> pairs.insert_with_by_ascending_key(key: "bar", value: 2, compare: bytearray.compare, with: add_integer)
///     |> pairs.insert_with_by_ascending_key(key: "foo", value: 3, compare: bytearray.compare, with: add_integer)
///
/// result == [Pair("bar", 2), Pair("foo", 4)]
/// ```
pub fn insert_with_by_ascending_key(
  self: Pairs<key, value>,
  key k: key,
  value v: value,
  compare: fn(key, key) -> Ordering,
  with: fn(value, value) -> value,
) -> Pairs<key, value> {
  when self is {
    [] -> [Pair(k, v)]
    [Pair(k2, v2), ..rest] ->
      if compare(k, k2) == Less {
        [Pair(k, v), ..self]
      } else {
        if k == k2 {
          [Pair(k, with(v, v2)), ..rest]
        } else {
          [
            Pair(k2, v2),
            ..insert_with_by_ascending_key(rest, k, v, compare, with)
          ]
        }
      }
  }
}

test insert_with_by_ascending_key_1() {
  let compare_un_b_data =
    fn(l, r) {
      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)
    }

  let m =
    []
      |> insert_with_by_ascending_key(
          "foo" |> builtin.b_data,
          42,
          compare_un_b_data,
          builtin.add_integer,
        )
      |> insert_with_by_ascending_key(
          "foo" |> builtin.b_data,
          14,
          compare_un_b_data,
          builtin.add_integer,
        )

  m == [Pair("foo" |> builtin.b_data, 56)]
}

test insert_with_by_ascending_key_2() {
  let compare_un_b_data =
    fn(l, r) {
      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)
    }

  let m =
    []
      |> insert_with_by_ascending_key(
          "foo" |> builtin.b_data,
          42,
          compare_un_b_data,
          builtin.add_integer,
        )
      |> insert_with_by_ascending_key(
          "bar" |> builtin.b_data,
          14,
          compare_un_b_data,
          builtin.add_integer,
        )
      |> insert_with_by_ascending_key(
          "baz" |> builtin.b_data,
          1337,
          compare_un_b_data,
          builtin.add_integer,
        )

  m == [
    Pair("bar" |> builtin.b_data, 14),
    Pair("baz" |> builtin.b_data, 1337),
    Pair("foo" |> builtin.b_data, 42),
  ]
}

test insert_with_by_ascending_key_3() {
  let compare_un_b_data =
    fn(l, r) {
      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)
    }

  let result =
    []
      |> insert_with_by_ascending_key(
          "foo" |> builtin.b_data,
          1,
          compare_un_b_data,
          builtin.add_integer,
        )
      |> insert_with_by_ascending_key(
          "bar" |> builtin.b_data,
          2,
          compare_un_b_data,
          builtin.add_integer,
        )
      |> insert_with_by_ascending_key(
          "foo" |> builtin.b_data,
          3,
          compare_un_b_data,
          builtin.add_integer,
        )

  result == [Pair("bar" |> builtin.b_data, 2), Pair("foo" |> builtin.b_data, 4)]
}

/// Apply a function to all key-value pairs in a alist, replacing the values.
///
/// ```aiken
/// let fixture = [Pair("a", 100), Pair("b", 200)]
///
/// pairs.map(fixture, fn(_k, v) { v * 2 }) == [Pair("a", 200), Pair("b", 400)]
/// ```
pub fn map(
  self: Pairs<key, value>,
  with: fn(key, value) -> result,
) -> Pairs<key, result> {
  when self is {
    [] -> []
    [Pair(k, v), ..rest] -> [Pair(k, with(k, v)), ..map(rest, with)]
  }
}

test map_1() {
  let fixture = [Pair("a", 1), Pair("b", 2)]

  map(fixture, with: fn(k, _) { k }) == [Pair("a", "a"), Pair("b", "b")]
}

test map_2() {
  let fixture = [Pair("a", 1), Pair("b", 2)]

  map(fixture, with: fn(_, v) { v + 1 }) == [Pair("a", 2), Pair("b", 3)]
}

/// Insert a value in the `Pairs` at a given key. If the key already exists,
/// its value is replaced.
///
/// > [!CAUTION]
/// > The list is only traversed up to the given key and the traversal
/// > stops as soon as a higher key is encountered. Said differently, the list
/// > is assumed to **be ordered by ascending keys**! If it is not, expect the
/// > unexpected.
///
/// ```aiken
/// use aiken/primitive/bytearray
///
/// let result =
///   []
///     |> pairs.repsert_by_ascending_key(key: "foo", value: 1, compare: bytearray.compare)
///     |> pairs.repsert_by_ascending_key(key: "bar", value: 2, compare: bytearray.compare)
///     |> pairs.repsert_by_ascending_key(key: "foo", value: 3, compare: bytearray.compare)
///
/// result == [Pair("bar", 2), Pair("foo", 3)]
/// ```
pub fn repsert_by_ascending_key(
  self: Pairs<key, value>,
  key k: key,
  value v: value,
  compare: fn(key, key) -> Ordering,
) -> Pairs<key, value> {
  when self is {
    [] -> [Pair(k, v)]
    [Pair(k2, v2), ..rest] ->
      if compare(k, k2) == Less {
        [Pair(k, v), ..self]
      } else {
        if k == k2 {
          [Pair(k, v), ..rest]
        } else {
          [Pair(k2, v2), ..repsert_by_ascending_key(rest, k, v, compare)]
        }
      }
  }
}

test repsert_by_ascending_key_1() {
  let m =
    []
      |> repsert_by_ascending_key("foo", 42, bytearray.compare)
      |> repsert_by_ascending_key("foo", 14, bytearray.compare)

  m == [Pair("foo", 14)]
}

test repsert_by_ascending_key_2() {
  let m =
    []
      |> repsert_by_ascending_key("foo", 42, bytearray.compare)
      |> repsert_by_ascending_key("bar", 14, bytearray.compare)
      |> repsert_by_ascending_key("baz", 1337, bytearray.compare)

  m == [Pair("bar", 14), Pair("baz", 1337), Pair("foo", 42)]
}

// ## Transforming

/// Fold over the key-value pairs in a pairs. The fold direction follows keys
/// in ascending order and is done from left-to-right.
///
/// ```aiken
/// let fixture = [
///   Pair(1, 100),
///   Pair(2, 200),
///   Pair(3, 300),
/// ]
///
/// pairs.foldl(fixture, 0, fn(k, v, result) { k * v + result }) == 1400
/// ```
pub fn foldl(
  self: Pairs<key, value>,
  zero: result,
  with: fn(key, value, result) -> result,
) -> result {
  when self is {
    [] -> zero
    [Pair(k, v), ..rest] -> foldl(rest, with(k, v, zero), with)
  }
}

test foldl_1() {
  foldl([], 14, fn(_, _, _) { 42 }) == 14
}

test foldl_2() {
  foldl(
    [Pair("a", 42), Pair("b", 14)],
    zero: 0,
    with: fn(_, v, total) { v + total },
  ) == 56
}

/// Fold over the key-value pairs in a Pairs. The fold direction follows the
/// order of elements in the Pairs and is done from right-to-left.
///
/// ```aiken
/// let fixture = [
///   Pair(1, 100),
///   Pair(2, 200),
///   Pair(3, 300),
/// ]
///
/// pairs.foldr(fixture, 0, fn(k, v, result) { k * v + result }) == 1400
/// ```
pub fn foldr(
  self: Pairs<key, value>,
  zero: result,
  with: fn(key, value, result) -> result,
) -> result {
  when self is {
    [] -> zero
    [Pair(k, v), ..rest] -> with(k, v, foldr(rest, zero, with))
  }
}

test foldr_1() {
  foldr([], 14, fn(_, _, _) { 42 }) == 14
}

test foldr_2() {
  foldr(
    [Pair("a", 42), Pair("b", 14)],
    zero: 0,
    with: fn(_, v, total) { v + total },
  ) == 56
}

test foldr_3() {
  let fixture = [Pair(1, 100), Pair(2, 200), Pair(3, 300)]

  foldr(fixture, 0, fn(k, v, result) { k * v + result }) == 1400
}



================================================
FILE: lib/aiken/collection/dict/strategy.ak
================================================
//// This module contains strategies used to transform [`Dict`](../dict.html#Dict). You can safely ignore this module if you aren't using [`union_with`](../dict.html#union_with) nor [`insert_with`](../dict.html#insert_with).

/// A strategy for combining two values in a dictionnary that belong to the same key.
pub type UnionStrategy<key, value> =
  fn(key, value, value, KeepValue<key, value>, DiscardValue<key, value>) ->
    Pairs<key, value>

/// A callback to keep a combined value at a given key
pub type KeepValue<key, value> =
  fn(value) -> Pairs<key, value>

/// A callback to discard a value at a given key
pub type DiscardValue<key, value> =
  fn() -> Pairs<key, value>

// ### Union Strategies

/// A strategy which always fail, enforcing the dict contains no duplicate.
///
/// ```aiken
/// fn(_, _, _, _, _) {
///   fail @"unexpected duplicate key found in dict."
/// }
/// ```
pub fn expect_no_duplicate() -> UnionStrategy<key, value> {
  fn(_, _, _, _, _) {
    fail @"unexpected duplicate key found in dict."
  }
}

/// Combine values by keeping the values present in the left-most dict.
///
/// ```aiken
/// fn(_key, left, _right, keep, _discard) { keep(left) }
/// ```
pub fn keep_left() -> UnionStrategy<key, value> {
  fn(_key, left, _right, keep, _discard) { keep(left) }
}

/// Combine values by keeping the values present in the right-most dict.
///
/// ```aiken
/// fn(_key, _left, right, keep, _discard) { keep(right) }
/// ```
pub fn keep_right() -> UnionStrategy<key, value> {
  fn(_key, _left, right, keep, _discard) { keep(right) }
}

/// Combine values by taking their sum.
///
/// ```aiken
/// fn(_key, left, right, keep, _discard) { keep(left + right) }
/// ```
pub fn sum() -> UnionStrategy<key, Int> {
  fn(_key, left, right, keep, _discard) { keep(left + right) }
}

/// Combine values by taking their sum, only if it is non-null. If the
/// resulting sum is 0, discard the key/value entirely.
///
/// ```aiken
/// fn(_key, left, right, keep, discard) {
///   let value = left + right
///   if value == 0 {
///     discard()
///   } else {
///     keep(value)
///   }
/// }
/// ```
pub fn sum_if_non_zero() -> UnionStrategy<key, Int> {
  fn(_key, left, right, keep, discard) {
    let value = left + right
    if value == 0 {
      discard()
    } else {
      keep(value)
    }
  }
}



================================================
FILE: lib/aiken/crypto/bitwise.ak
================================================
//// @hidden

use aiken/builtin

pub opaque type State<t> {
  inner: Int,
}

pub const zero = State { inner: 0 }

pub const one = State { inner: 1 }

pub fn add_bits(field: Int, big_endian: Bool) {
  fn(state: State<t>, bytes: ByteArray) -> State<t> {
    builtin.bytearray_to_integer(big_endian, bytes)
      |> builtin.add_integer(state.inner, _)
      |> builtin.mod_integer(field)
      |> State
  }
}

pub fn add_int(field: Int) {
  fn(state: State<t>, int: Int) -> State<t> {
    state.inner + int
      |> builtin.mod_integer(field)
      |> State
  }
}

pub fn add_state(field: Int) {
  fn(state: State<t>, other: State<t>) -> State<t> {
    state.inner + other.inner
      |> builtin.mod_integer(field)
      |> State
  }
}

pub fn sub_bits(field: Int, big_endian: Bool) {
  fn(state: State<t>, bytes: ByteArray) -> State<t> {
    builtin.bytearray_to_integer(big_endian, bytes)
      |> builtin.subtract_integer(state.inner, _)
      |> builtin.mod_integer(field)
      |> State
  }
}

pub fn sub_int(field: Int) {
  fn(state: State<t>, int: Int) -> State<t> {
    state.inner - int
      |> builtin.mod_integer(field)
      |> State
  }
}

pub fn sub_state(field: Int) {
  fn(state: State<t>, other: State<t>) -> State<t> {
    state.inner - other.inner
      |> builtin.mod_integer(field)
      |> State
  }
}

pub fn mul_bits(field: Int, big_endian: Bool) {
  fn(state: State<t>, bytes: ByteArray) -> State<t> {
    builtin.bytearray_to_integer(big_endian, bytes)
      |> builtin.multiply_integer(state.inner, _)
      |> builtin.mod_integer(field)
      |> State
  }
}

pub fn mul_int(field: Int) {
  fn(state: State<t>, int: Int) -> State<t> {
    state.inner * int
      |> builtin.mod_integer(field)
      |> State
  }
}

pub fn mul_state(field: Int) {
  fn(state: State<t>, other: State<t>) -> State<t> {
    state.inner * other.inner
      |> builtin.mod_integer(field)
      |> State
  }
}

pub fn scale(
  self: State<t>,
  e: Int,
  mul: fn(State<t>, State<t>) -> State<t>,
) -> State<t> {
  if e < 0 {
    zero
  } else if e == 0 {
    one
  } else if e % 2 == 0 {
    scale(mul(self, self), e / 2, mul)
  } else {
    mul(self, scale(mul(self, self), ( e - 1 ) / 2, mul))
  }
}

/// A faster version of `scale` for the case where the exponent is a power of two.
/// That is, the exponent $e = 2^k$ for some non-negative integer $k$. Which is used a lot in zk-SNARKs.
pub fn scale2(self: State<t>, k: Int, mul: fn(State<t>, State<t>) -> State<t>) {
  if k < 0 {
    zero
  } else {
    do_scale2(self, k, mul)
  }
}

fn do_scale2(self: State<t>, k: Int, mul) -> State<t> {
  if k == 0 {
    self
  } else {
    do_scale2(mul(self, self), k - 1, mul)
  }
}

pub fn neg(field: Int) {
  fn(state: State<t>) -> State<t> {
    ( field - state.inner ) % field
      |> State
  }
}

pub fn to_int(state: State<t>) -> Int {
  state.inner
}

pub fn from_int(int: Int, field: Int) -> State<t> {
  int % field
    |> State
}



================================================
FILE: lib/aiken/crypto/int224.ak
================================================
//// This module implements arithmetic operations in a constrained 224-bit integer field.
//// Operations are performed modulo $2^{224}$, providing a field for cryptographic operations
//// that require 28-byte values.
////
//// The module provides functionality for basic arithmetic operations (addition, subtraction,
//// multiplication) within this constrained field, as well as conversion functions between
//// different representations.

use aiken/builtin
use aiken/crypto/bitwise

pub opaque type Bits224 {
  Bits224
}

pub type State =
  bitwise.State<Bits224>

type Over<a> =
  fn(State, a) -> State

/// The prime defining the 224-bit integer field $2^{224}$
pub const field =
  builtin.replicate_byte(28, 0)
    |> builtin.cons_bytearray(1, _)
    |> builtin.bytearray_to_integer(True, _)

/// The field size, in **bytes**.
pub const field_size = 28

// ## Constructing

/// Constructs a new `Bits224` element from a Big-Endian (most-significant bits first) `ByteArray`.
pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {
  bytes
    |> builtin.bytearray_to_integer(True, _)
    |> bitwise.from_int(field)
}

/// Constructs a new `Bits224` element from a Little-Endian (least-significant bits first) `ByteArray`.
pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {
  bytes
    |> builtin.bytearray_to_integer(False, _)
    |> bitwise.from_int(field)
}

/// Constructs a new `Bits224` element from an integer, ensuring it's within the valid range of the field.
pub fn from_int(int: Int) -> State {
  bitwise.from_int(int, field)
}

// ## Modifying

/// Exponentiates a `Bits224` element by a non-negative integer exponent, using repeated squaring.
/// Note that this function returns `zero` for negative exponents.
pub fn scale(self: State, e: Int) -> State {
  bitwise.scale(self, e, mul)
}

/// A faster version of `scale` for the case where the exponent is a power of two.
/// That is, the exponent $e = 2^k$ for some non-negative integer $k$.
pub fn scale2(self: State, k: Int) -> State {
  bitwise.scale2(self, k, mul)
}

// ## Combining

const add_s_bits224: Over<State> = bitwise.add_state(field)

/// Adds two `Bits224` elements, ensuring the result stays within the finite field range.
pub fn add(left: State, right: State) -> State {
  add_s_bits224(left, right)
}

const add_bit224: Over<ByteArray> = bitwise.add_bits(field, True)

/// Adds a ByteArray to a `Bits224` element, interpreting bytes as a big-endian number.
pub fn add_bytes(self: State, bytes: ByteArray) -> State {
  add_bit224(self, bytes)
}

const add_i224: Over<Int> = bitwise.add_int(field)

/// Adds an integer to a `Bits224` element.
pub fn add_int(self: State, int: Int) -> State {
  add_i224(self, int)
}

const mul_s_bits224: Over<State> = bitwise.mul_state(field)

/// Multiplies two `Bits224` elements, with the result constrained within the finite field.
pub fn mul(left: State, right: State) -> State {
  mul_s_bits224(left, right)
}

const mul_bit224: Over<ByteArray> = bitwise.mul_bits(field, True)

/// Multiplies a `Bits224` element by a ByteArray, interpreting bytes as a big-endian number.
pub fn mul_bytes(self: State, bytes: ByteArray) -> State {
  mul_bit224(self, bytes)
}

const mul_i224: Over<Int> = bitwise.mul_int(field)

/// Multiplies a `Bits224` element by an integer.
pub fn mul_int(self: State, int: Int) -> State {
  mul_i224(self, int)
}

const neg224: fn(State) -> State = bitwise.neg(field)

/// Calculates the additive inverse of a `Bits224` element.
pub fn neg(self: State) -> State {
  neg224(self)
}

const sub_s_bits224: Over<State> = bitwise.sub_state(field)

/// Subtracts one `Bits224` element from another, with the result wrapped within the finite field range.
pub fn sub(left: State, right: State) -> State {
  sub_s_bits224(left, right)
}

const sub_bit224: Over<ByteArray> = bitwise.sub_bits(field, True)

/// Subtracts a `ByteArray` from a `Bits224` element, interpreting bytes as a big-endian number.
pub fn sub_bytes(self: State, bytes: ByteArray) -> State {
  sub_bit224(self, bytes)
}

const sub_i224: Over<Int> = bitwise.sub_int(field)

/// Subtracts an integer from a `Bits224` element.
pub fn sub_int(self: State, int: Int) -> State {
  sub_i224(self, int)
}

// ## Transforming

/// Converts a `Bits224` element to a Big-Endian (most-significant bits first) `ByteArray`.
pub fn to_bytearray_big_endian(self: State) -> ByteArray {
  bitwise.to_int(self)
    |> builtin.integer_to_bytearray(True, field_size, _)
}

/// Converts a `Bits224` element to a Little-Endian (least-significant bits first) `ByteArray`.
pub fn to_bytearray_little_endian(self: State) -> ByteArray {
  bitwise.to_int(self)
    |> builtin.integer_to_bytearray(False, field_size, _)
}

/// Converts a `Bits224` element back to its integer representation.
pub fn to_int(self: State) -> Int {
  bitwise.to_int(self)
}



================================================
FILE: lib/aiken/crypto/int256.ak
================================================
//// This module implements arithmetic operations in a constrained 256-bit integer field.
//// Operations are performed modulo $2^{256}$, providing a field for cryptographic operations
//// that require 32-byte values.
////
//// The module provides functionality for basic arithmetic operations (addition, subtraction,
//// multiplication) within this constrained field, as well as conversion functions between
//// different representations.

use aiken/builtin
use aiken/crypto/bitwise

/// The prime defining the 256-bit integer field $2^{256}$
pub const field =
  builtin.replicate_byte(32, 0)
    |> builtin.cons_bytearray(1, _)
    |> builtin.bytearray_to_integer(True, _)

pub const field_size = 32

pub opaque type Bits256 {
  Bits256
}

pub type State =
  bitwise.State<Bits256>

type Over<a> =
  fn(State, a) -> State

// ## Constructing

/// Constructs a new `Bits256` element from a Big-Endian (most-significant bits first) `ByteArray`.
pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {
  bytes
    |> builtin.bytearray_to_integer(True, _)
    |> bitwise.from_int(field)
}

/// Constructs a new `Bits256` element from a Little-Endian (least-significant bits first) `ByteArray`.
pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {
  bytes
    |> builtin.bytearray_to_integer(False, _)
    |> bitwise.from_int(field)
}

/// Constructs a new `Bits256` element from an integer, ensuring it's within the valid range of the field.
pub fn from_int(int: Int) -> State {
  bitwise.from_int(int, field)
}

// ## Modifying

/// Exponentiates a `Bits256` element by a non-negative integer exponent, using repeated squaring.
/// Note that this function returns `zero` for negative exponents.
pub fn scale(self: State, e: Int) -> State {
  bitwise.scale(self, e, mul)
}

/// A faster version of `scale` for the case where the exponent is a power of two.
/// That is, the exponent $e = 2^k$ for some non-negative integer $k$.
pub fn scale2(self: State, k: Int) -> State {
  bitwise.scale2(self, k, mul)
}

// ## Combining

const add_s_hash256: Over<State> = bitwise.add_state(field)

/// Adds two `Bits256` elements, ensuring the result stays within the finite field range.
pub fn add(left: State, right: State) -> State {
  add_s_hash256(left, right)
}

const add_bit256: Over<ByteArray> = bitwise.add_bits(field, True)

/// Adds a ByteArray to a `Bits256` element, interpreting bytes as a big-endian number.
pub fn add_bytes(self: State, bytes: ByteArray) -> State {
  add_bit256(self, bytes)
}

const add_i256: Over<Int> = bitwise.add_int(field)

/// Adds an integer to a `Bits256` element.
pub fn add_int(self: State, int: Int) -> State {
  add_i256(self, int)
}

const mul_s_hash256: Over<State> = bitwise.mul_state(field)

/// Multiplies two `Bits256` elements, with the result constrained within the finite field.
pub fn mul(left: State, right: State) -> State {
  mul_s_hash256(left, right)
}

const mul_bit256: Over<ByteArray> = bitwise.mul_bits(field, True)

/// Multiplies a `Bits256` element by a ByteArray, interpreting bytes as a big-endian number.
pub fn mul_bytes(self: State, bytes: ByteArray) -> State {
  mul_bit256(self, bytes)
}

const mul_i256: Over<Int> = bitwise.mul_int(field)

/// Multiplies a `Bits256` element by an integer.
pub fn mul_int(self: State, int: Int) -> State {
  mul_i256(self, int)
}

const neg256: fn(State) -> State = bitwise.neg(field)

/// Calculates the additive inverse of a `Bits256` element.
pub fn neg(self: State) -> State {
  neg256(self)
}

const sub_s_hash256: Over<State> = bitwise.sub_state(field)

/// Subtracts one `Bits256` element from another, with the result wrapped within the finite field range.
pub fn sub(left: State, right: State) -> State {
  sub_s_hash256(left, right)
}

const sub_bit256: Over<ByteArray> = bitwise.sub_bits(field, True)

/// Subtracts a `ByteArray` from a `Bits256` element, interpreting bytes as a big-endian number.
pub fn sub_bytes(self: State, bytes: ByteArray) -> State {
  sub_bit256(self, bytes)
}

const sub_i256: Over<Int> = bitwise.sub_int(field)

/// Subtracts an integer from a `Bits256` element.
pub fn sub_int(self: State, int: Int) -> State {
  sub_i256(self, int)
}

// ## Transforming

/// Converts a `Bits256` element to a Big-Endian (most-significant bits first) `ByteArray`.
pub fn to_bytearray_big_endian(self: State) -> ByteArray {
  bitwise.to_int(self)
    |> builtin.integer_to_bytearray(True, field_size, _)
}

/// Converts a `Bits256` element to a Little-Endian (least-significant bits first) `ByteArray`.
pub fn to_bytearray_little_endian(self: State) -> ByteArray {
  bitwise.to_int(self)
    |> builtin.integer_to_bytearray(False, field_size, _)
}

/// Converts a `Bits256` element back to its integer representation.
pub fn to_int(self: State) -> Int {
  bitwise.to_int(self)
}



================================================
FILE: lib/aiken/crypto/bls12_381/g1.ak
================================================
//// This module is designed for cryptographic operations involving the BLS12-381 elliptic curve, particularly focusing on the G1 group of the curve.
////
//// The key functionalities provided by this module include:
//// - Defining the generator of the G1 group, which is a fixed base point on the elliptic curve used for various cryptographic computations.
//// - Implementing the additive identity (zero) in the G1 group, which plays a crucial role in elliptic curve arithmetic.
//// - Providing functions to compress and decompress points in the G1 group. Compression reduces the size of the point representation, which is useful for efficient storage and transmission. Decompression restores the original point from its compressed form.
//// - Implementing basic arithmetic operations on the points in the G1 group, such as addition and subtraction.
//// - Enabling the exponentiation of a point in the G1 group with a scalar, which is a fundamental operation in elliptic curve cryptography.
//// - Offering a function to hash arbitrary data to a point in the G1 group, a process important in several cryptographic protocols.
////
//// This module ensures that all operations respect the properties of the BLS12-381 curve and the mathematical structure of the G1 group.

use aiken/builtin
use aiken/crypto/bitwise.{State}
use aiken/crypto/bls12_381/scalar.{Scalar}

/// The compressed generator of the G1 group of the BLS12-381 curve.
/// This constant represents a fixed base point on the elliptic curve.
/// Note that flat encoded plutus does not allow for the direct usage of BLS12-381 points.
/// More explicit, any points in plutus data or scripts must be decompressed before usage onchain.
pub const generator: G1Element =
  #<Bls12_381, G1>"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"

test generator_1() {
  builtin.bls12_381_g1_scalar_mul(scalar.field_prime, generator) == #<Bls12_381, G1>"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
}

/// Represents the additive identity (zero) in the G1 group.
/// Note that flat encoded plutus does not allow for the direct usage of BLS12-381 points.
/// More explicit, any points in plutus data or scripts must be decompressed before usage onchain.
pub const zero: G1Element =
  #<Bls12_381, G1>"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"

test zero_1() {
  and {
    zero == builtin.bls12_381_g1_scalar_mul(scalar.field_prime, generator),
    zero == builtin.bls12_381_g1_scalar_mul(
      scalar.field_prime,
      #<Bls12_381, G1>"88c7e388ee58f1db9a24d7098b01d13634298bebf2d159254975bd450cb0d287fcc622eb71edde8b469a8513551baf1f",
    ),
    zero == builtin.bls12_381_g1_scalar_mul(
      scalar.field_prime,
      #<Bls12_381, G1>"a6ac32e625dc30b8d31bacf5f4c89c27b0388b15f57ae10de8d5cec02dd1f113c9a31077be05ab587ca57a88d34deb75",
    ),
  }
}

/// Compresses a point in the G1 group into a more compact representation.
/// The compressed representation is a 48-byte string, corresponding to a modified `x` coordinate.
/// The leading most significant 3 bits of this string indicate how to reconstruct the `y` coordinate.
///
/// > [!NOTE]
/// > More explicitly via [Zcash's spec](https://github.com/supranational/blst#serialization-format):
/// >
/// > <i>The most-significant three bits of a G1 or G2 encoding should be masked away before the coordinate(s) are interpreted. These bits are used to unambiguously represent the underlying element:
/// >
/// > - The most significant bit, when set, indicates that the point is in compressed form. Otherwise, the point is in uncompressed form.
/// > - The second-most significant bit indicates that the point is at infinity. If this bit is set, the remaining bits of the group element's encoding should be set to zero.
/// > - The third-most significant bit is set if (and only if) this point is in compressed form and it is not the point at infinity and its y-coordinate is the lexicographically largest of the two associated with the encoded x-coordinate.</i>
pub fn compress(point) {
  builtin.bls12_381_g1_compress(point)
}

test compress_1() {
  compress(
    #<Bls12_381, G1>"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb",
  ) == #"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"
}

/// Decompresses a point in the G1 group from its compressed form.
pub fn decompress(bytes) {
  builtin.bls12_381_g1_uncompress(bytes)
}

pub fn equal(left, right) {
  builtin.bls12_381_g1_equal(left, right)
}

test equal_1() {
  equal(generator, generator)
}

/// Adds two points in the G1 group.
pub fn add(left, right) {
  builtin.bls12_381_g1_add(left, right)
}

/// Subtracts one point in the G1 group from another.
pub fn sub(left, right) {
  builtin.bls12_381_g1_add(left, builtin.bls12_381_g1_neg(right))
}

test sub_1() {
  generator == sub(add(generator, generator), generator)
}

/// Exponentiates a point in the G1 group with a `scalar`.
/// This operation is equivalent to the repeated addition of the point with itself `e` times.
pub fn scale(point, e: State<Scalar>) {
  builtin.bls12_381_g1_scalar_mul(scalar.to_int(e), point)
}

test scale_1() {
  let x = scalar.from_int(2)
  builtin.bls12_381_g1_add(generator, generator) == scale(generator, x)
}

/// Hashes arbitrary data to a point in the G1 group.
/// You can use the `domain_separation_tag` parameter to cryptographically separate different uses of the hash function between applications.
pub fn hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) {
  builtin.bls12_381_g1_hash_to_group(bytes, domain_separation_tag)
}

test hash_to_group_1() {
  hash_to_group("hello", "world") == #<Bls12_381, G1>"89223b03c629cc6bcbbdccbba46b6679bc6a79db82f2d3bd115899a45a5a38c391587b59d3d1e297f977d1c4ee9e3388"
}



================================================
FILE: lib/aiken/crypto/bls12_381/g2.ak
================================================
//// This module is designed for cryptographic operations involving the BLS12-381 elliptic curve, particularly focusing on the G2 group of the curve.
////
//// The key functionalities provided by this module include:
//// - Defining the generator of the G2 group, which is a fixed base point on the elliptic curve used for various cryptographic computations.
//// - Implementing the additive identity (zero) in the G2 group, which plays a crucial role in elliptic curve arithmetic.
//// - Providing functions to compress and decompress points in the G2 group. Compression reduces the size of the point representation, which is useful for efficient storage and transmission. Decompression restores the original point from its compressed form.
//// - Implementing basic arithmetic operations on the points in the G2 group, such as addition and subtraction.
//// - Enabling the exponentiation of a point in the G2 group with a scalar, which is a fundamental operation in elliptic curve cryptography.
//// - Offering a function to hash arbitrary data to a point in the G2 group, a process important in several cryptographic protocols.
////
//// This module ensures that all operations respect the properties of the BLS12-381 curve and the mathematical structure of the G2 group.

use aiken/builtin
use aiken/crypto/bitwise.{State}
use aiken/crypto/bls12_381/scalar.{Scalar}

/// The compressed generator of the G2 group of the BLS12-381 curve.
/// This constant represents a fixed base point on the elliptic curve.
/// Note that flat encoded plutus does not allow for the direct usage of BLS12-381 points.
/// More explicit, any points in plutus data or scripts must be decompressed before usage onchain.
pub const generator: G2Element =
  #<Bls12_381, G2>"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"

/// Basic Domain Separation Tag as per the [IETF](https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-4.2.1).
pub const domain_separation_tag_basic =
  "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_"

test generator_1() {
  builtin.bls12_381_g2_scalar_mul(scalar.field_prime, generator) == #<Bls12_381, G2>"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
}

/// Represents the additive identity (zero) in the G2 group.
/// Note that flat encoded plutus does not allow for the direct usage of BLS12-381 points.
/// More explicit, any points in plutus data or scripts must be decompressed before usage onchain.
pub const zero: G2Element =
  #<Bls12_381, G2>"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"

test zero_1() {
  and {
    zero == builtin.bls12_381_g2_scalar_mul(scalar.field_prime, generator),
    zero == builtin.bls12_381_g2_scalar_mul(
      scalar.field_prime,
      #<Bls12_381, G2>"9964a9ac2ee28a4dab595ff0970d446373bf46701c5d0b29ce8e1ba995d811a1c7b193c928269192c64ba1fbe4b1940207c251e086b452b920bc72e3cebab46ce672b9b088ca620a471d3b888d9737f6abd165319aa457dbf8835e3d34196051",
    ),
    zero == builtin.bls12_381_g2_scalar_mul(
      scalar.field_prime,
      #<Bls12_381, G2>"a900e25cb53cf1eeb1a82c0c83292937c49c97966351273767a204256a7ef6e95aa391404387075d361e7b13ccd694db03aa73ee0e1bd2c3dd735582b99fdf71696de72e4eda18ae99ea45995f1c9605aa0057008ee9a4da604b5716fb4a345b",
    ),
  }
}

/// Compresses a point in the G2 group into a more compact representation.
/// The compressed representation is the concatenation of two 48-byte strings, corresponding to a modified and complexified `x` coordinate.
/// The leading most significant 3 bits of this string indicate how to reconstruct the `y` coordinate.
///
/// > [!NOTE]
/// > More explicitly via [Zcash's spec](https://github.com/supranational/blst#serialization-format):
/// >
/// > <i>The most-significant three bits of a G1 or G2 encoding should be masked away before the coordinate(s) are interpreted. These bits are used to unambiguously represent the underlying element:
/// >
/// > - The most significant bit, when set, indicates that the point is in compressed form. Otherwise, the point is in uncompressed form.
/// > - The second-most significant bit indicates that the point is at infinity. If this bit is set, the remaining bits of the group element's encoding should be set to zero.
/// > - The third-most significant bit is set if (and only if) this point is in compressed form and it is not the point at infinity and its y-coordinate is the lexicographically largest of the two associated with the encoded x-coordinate.</i>
pub fn compress(point) {
  builtin.bls12_381_g2_compress(point)
}

test compress_1() {
  let g2 =
    #<Bls12_381, G2>"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"
  compress(g2) == #"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"
}

/// Decompresses a point in the G2 group from its compressed form.
pub fn decompress(bytes) {
  builtin.bls12_381_g2_uncompress(bytes)
}

test decompress_1() {
  let g2 =
    #<Bls12_381, G2>"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"
  generator == g2
}

pub fn equal(left, right) {
  builtin.bls12_381_g2_equal(left, right)
}

test equal_1() {
  equal(
    generator,
    #<Bls12_381, G2>"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8",
  )
}

/// Adds two points in the G2 group.
pub fn add(left, right) {
  builtin.bls12_381_g2_add(left, right)
}

/// Subtracts one point in the G2 group from another.
pub fn sub(left, right) {
  builtin.bls12_381_g2_add(left, builtin.bls12_381_g2_neg(right))
}

test sub_1() {
  generator == sub(add(generator, generator), generator)
}

/// Exponentiates a point in the G2 group with a `scalar`.
/// This operation is equivalent to the repeated addition of the point with itself `e` times.
pub fn scale(point, e: State<Scalar>) {
  builtin.bls12_381_g2_scalar_mul(scalar.to_int(e), point)
}

test scale_1() {
  let x = scalar.from_int(2)
  builtin.bls12_381_g2_add(generator, generator) == scale(generator, x)
}

/// Hashes arbitrary data to a point in the G2 group.
/// You can use the `domain_separation_tag` parameter to cryptographically separate different uses of the hash function between applications.
pub fn hash_to_group(bytes, domain_separation_tag) {
  builtin.bls12_381_g2_hash_to_group(bytes, domain_separation_tag)
}

test hash_to_group_1() {
  hash_to_group("hello", "world") == #<Bls12_381, G2>"a18486bba1dc8321f4998ed4268c6df8dfa5618dd5c91595844059d517f8104bf8031d3e766f9c99db1d6f58b201ee9614de92fc08f9e5cc3a6cd814e871857cb6e3924e8a4fa48775116c5f158d58ceda63614d62f6b7bc47db798d656969a5"
}



================================================
FILE: lib/aiken/crypto/bls12_381/pairing.ak
================================================
use aiken/builtin.{bls12_381_final_verify, bls12_381_miller_loop}
use aiken/crypto/bitwise.{State}
use aiken/crypto/bls12_381/g1
use aiken/crypto/bls12_381/g2
use aiken/crypto/bls12_381/scalar.{Scalar}

/// Computes a MillerLoop over the elements `q` and `p`
pub fn miller_loop(q: G1Element, p: G2Element) -> MillerLoopResult {
  bls12_381_miller_loop(q, p)
}

/// Final exponentiation against two `MillerLoopResult`.
///
/// ```aiken
/// prove: e(q^x, p^m) == e(q, p^m*x)
/// let secret: State<Scalar> = scalar.from_int(44203)
///
/// let public_value: G1Element = g1.generator |> g1.scale(secret)
///
/// let message: ByteArray = #"acab"
///
/// let challenge: G2Element =
///   message |> g2.hash_to_group(g2.domain_separation_tag_basic)
///
/// let witness: G2Element =
///   message
///     |> g2.hash_to_group(g2.domain_separation_tag_basic)
///     |> g2.scale(secret)
///
/// final_exponentiation(
///   miller_loop(public_value, challenge),
///   miller_loop(g1.generator, witness),
/// )
/// ```
pub fn final_exponentiation(
  left: MillerLoopResult,
  right: MillerLoopResult,
) -> Bool {
  bls12_381_final_verify(left, right)
}

// prove: e(q^x, p^m) == e(q, p^m*x)
test simple_miller_loop_with_final_exponentiation() {
  let secret: State<Scalar> = scalar.from_int(44203)

  let public_value: G1Element = g1.generator |> g1.scale(secret)

  let message: ByteArray = #"acab"

  let challenge: G2Element =
    message |> g2.hash_to_group(g2.domain_separation_tag_basic)

  let witness: G2Element =
    message
      |> g2.hash_to_group(g2.domain_separation_tag_basic)
      |> g2.scale(secret)

  final_exponentiation(
    miller_loop(public_value, challenge),
    miller_loop(g1.generator, witness),
  )
}



================================================
FILE: lib/aiken/crypto/bls12_381/scalar.ak
================================================
//// This module implements arithmetic operations in the scalar field associated with the BLS12-381 elliptic curve.
//// The scalar field, defined over a prime number `q`, is derived from the order of the subgroup G1.
////
//// More explicitly, we have the identity:
////
//// ```aiken
//// builtin.bls12_381_g1_scalar_mul(q, bls12_381_g1_generator) == 1
//// ```
////
//// where,
////
//// ```aiken
//// q = 52435875175126190479447740508185965837690552500527637822603658699938581184513
//// ```
////
//// This module provides functionality for basic arithmetic operations (addition, subtraction, multiplication, division) within this scalar field.
//// Additionally, it includes advanced operations such as exponentiation and calculation of multiplicative inverses, tailored for cryptographic applications.

use aiken/builtin
use aiken/crypto/bitwise.{State, one, zero}

/// The prime number defining the scalar field of the BLS12-381 curve.
pub const field_prime =
  52435875175126190479447740508185965837690552500527637822603658699938581184513

pub const field_size = 32

pub type Scalar =
  ByteArray

test field_prime_1() {
  builtin.integer_to_bytearray(True, 32, field_prime) == #"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001"
}

// ## Constructing
/// Constructs a new `Scalar` element from a Big-Endian (most-significant bits first) `ByteArray`.
pub fn from_bytes(b: ByteArray) -> State<Scalar> {
  b
    |> builtin.bytearray_to_integer(True, _)
    |> bitwise.from_int(field_prime)
}

/// Constructs a new `Scalar` element from a Little-Endian (least-significant bits first) `ByteArray`.
pub fn from_bytes_little_endian(bytes: ByteArray) -> State<Scalar> {
  bytes
    |> builtin.bytearray_to_integer(False, _)
    |> bitwise.from_int(field_prime)
}

/// Constructs a new `Scalar` element from an integer, ensuring it's within the valid range of the field.
pub fn from_int(n: Int) -> State<Scalar> {
  bitwise.from_int(n, field_prime)
}

test new_1() {
  trace from_int(-1)
  and {
    ( from_int(-1) |> to_int ) == field_prime - 1,
    ( from_int(field_prime) |> to_int ) == 0,
    ( from_int(834884848) |> to_int ) == 834884848,
  }
}

test from_bytearray_big_endian_1() {
  ( from_bytes(#"ffff00") |> to_int ) == 16776960
}

test from_bytearray_little_endian_1() {
  ( from_bytes_little_endian(#"ffff00") |> to_int ) == 65535
}

type BitwiseScalarBytes =
  fn(State<Scalar>, ByteArray) -> State<Scalar>

type BitwiseScalarInt =
  fn(State<Scalar>, Int) -> State<Scalar>

type BitwiseScalarState =
  fn(State<Scalar>, State<Scalar>) -> State<Scalar>

// ## Modifying

/// Exponentiates an `Scalar` element by a non-negative integer exponent, using repeated squaring.
/// Note that this function returns `scalar.zero` for negative exponents.
/// A dedicated builtin function for this is in the making, see CIP 109.
pub fn scale(self: State<Scalar>, e: Int) -> State<Scalar> {
  bitwise.scale(self, e, mul)
}

test scale_1() {
  let x = from_int(834884848)

  and {
    ( x |> scale(-1) ) == zero,
    ( x |> scale(0) ) == one,
    ( x |> scale(1) ) == x,
    ( x |> scale(2) |> to_int ) == 697032709419983104,
    ( x |> scale(3) |> to_int ) == 581942047655130761945608192,
    (
      from_int(field_prime - 4)
        |> scale(200)
        |> to_int
    ) == 12843927705572658539565969578937286576443167978938369866871449552629978143484,
  }
}

/// A faster version of `scale` for the case where the exponent is a power of two.
/// That is, the exponent `e = 2^k` for some non-negative integer `k`. Which is used alot in zk-SNARKs.
pub fn scale2(self: State<Scalar>, k: Int) -> State<Scalar> {
  bitwise.scale2(self, k, mul)
}

test scale2_1() {
  let x = from_int(834884848)

  and {
    scale2(x, -1) == zero,
    scale2(x, 0) == scale(x, 1),
    scale2(x, 1) == scale(x, 2),
    scale2(x, 2) == scale(x, 4),
    scale2(x, 3) == scale(x, 8),
    scale2(x, 4) == scale(x, 16),
  }
}

// ## Combining

const add_s_scalar: BitwiseScalarState = bitwise.add_state(field_prime)

/// Adds two `Scalar` elements, ensuring the result stays within the finite field range.
pub fn add(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {
  add_s_scalar(left, right)
}

const add_bit_scalar: BitwiseScalarBytes = bitwise.add_bits(field_prime, True)

pub fn add_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {
  add_bit_scalar(intermediate, bytes)
}

const add_i_scalar: BitwiseScalarInt = bitwise.add_int(field_prime)

pub fn add_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {
  add_i_scalar(intermediate, int)
}

test add_1() {
  let x = from_int(834884848)
  let y = from_int(field_prime - 1)
  let z = from_int(3)

  and {
    (( add(x, x) |> to_int ) == 1669769696)?,
    (add(y, one) == zero)?,
    (add(z, add(y, one)) == z)?,
  }
}

/// Divides one `Scalar` element by another, returning `None` if the divisor is zero.
pub fn div(left: State<Scalar>, right: State<Scalar>) -> Option<State<Scalar>> {
  if right == zero {
    None
  } else {
    Some(mul(left, scale(right, field_prime - 2)))
  }
}

pub fn div_int(left: State<Scalar>, right: Int) -> Option<State<Scalar>> {
  let right = from_int(right)
  if right == zero {
    None
  } else {
    Some(mul(left, scale(right, field_prime - 2)))
  }
}

pub fn div_bytes(left: State<Scalar>, right: ByteArray) -> Option<State<Scalar>> {
  let right = from_bytes(right)

  if right == zero {
    None
  } else {
    Some(mul(left, scale(right, field_prime - 2)))
  }
}

test div_1() {
  let x = from_int(834884848)

  and {
    div(x, x) == Some(one),
    div(x, zero) == None,
    div(from_int(field_prime - 1), from_int(2)) == Some(
      from_int(
        26217937587563095239723870254092982918845276250263818911301829349969290592256,
      ),
    ),
  }
}

const mul_s_scalar: BitwiseScalarState = bitwise.mul_state(field_prime)

/// Multiplies two `Scalar` elements, with the result constrained within the finite field.
pub fn mul(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {
  mul_s_scalar(left, right)
}

const mul_bit_scalar: BitwiseScalarBytes = bitwise.mul_bits(field_prime, True)

pub fn mul_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {
  mul_bit_scalar(intermediate, bytes)
}

const mul_i_scalar: BitwiseScalarInt = bitwise.mul_int(field_prime)

pub fn mul_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {
  mul_i_scalar(intermediate, int)
}

test mul_1() {
  let x = from_int(834884848)
  and {
    mul(x, x) == from_int(697032709419983104),
    mul(zero, x) == zero,
    mul(from_int(field_prime - 1), from_int(2)) == from_int(
      52435875175126190479447740508185965837690552500527637822603658699938581184511,
    ),
  }
}

const neg_scalar: fn(State<Scalar>) -> State<Scalar> = bitwise.neg(field_prime)

/// Calculates the additive inverse of a `Scalar` element.
pub fn neg(intermediate: State<Scalar>) -> State<Scalar> {
  neg_scalar(intermediate)
}

test neg_1() {
  trace neg(zero)

  and {
    neg(from_int(834884848)) == from_int(
      52435875175126190479447740508185965837690552500527637822603658699937746299665,
    ),
    neg(zero) == zero,
    neg(one) == from_int(field_prime - 1),
  }
}

/// Calculates the multiplicative inverse of an `Scalar` element, returning `None` if the element is zero.
pub fn recip(self: State<Scalar>) -> Option<State<Scalar>> {
  div(one, self)
}

test recip_1() {
  and {
    recip(from_int(834884848)) == Some(
      from_int(
        35891248691642227249400403463796410930702563777316955162085759263735363466421,
      ),
    ),
    recip(zero) == None,
  }
}

const sub_s_scalar: BitwiseScalarState = bitwise.sub_state(field_prime)

/// Subtracts one `Scalar` element from another, with the result wrapped within the finite field range.
pub fn sub(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {
  sub_s_scalar(left, right)
}

const sub_bit_scalar: BitwiseScalarBytes = bitwise.sub_bits(field_prime, True)

pub fn sub_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {
  sub_bit_scalar(intermediate, bytes)
}

const sub_i_scalar: BitwiseScalarInt = bitwise.sub_int(field_prime)

pub fn sub_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {
  sub_i_scalar(intermediate, int)
}

test sub_1() {
  let x = from_int(834884848)

  and {
    (sub(x, x) == zero)?,
    (sub(zero, from_int(5)) == from_int(field_prime - 5))?,
  }
}

// ## Transforming

/// Converts a `Scalar` element back to its integer representation.
pub fn to_int(s: State<Scalar>) -> Int {
  bitwise.to_int(s)
}

/// Converts a `Scalar` element to a Big-Endian (most-significant bits first) `ByteArray`.
pub fn to_bytes(s: State<Scalar>) -> ByteArray {
  s |> bitwise.to_int |> builtin.integer_to_bytearray(True, field_size, _)
}

/// Converts a `Scalar` element to a Little-Endian (least-significant bits first) `ByteArray`.
pub fn to_bytes_little_endian(s: State<Scalar>) -> ByteArray {
  s |> bitwise.to_int |> builtin.integer_to_bytearray(False, field_size, _)
}

test to_int_1() {
  to_int(from_int(834884848)) == 834884848
}

test to_bytearray_1() {
  ( to_bytes(from_int(16777215)) |> builtin.slice_bytearray(29, 32, _) ) == #"ffffff"
}



================================================
FILE: lib/aiken/math/rational.ak
================================================
//// This module implements operations between rational numbers.
////
//// > [!CAUTION]
//// > Internally, rational aren't automatically reduced as this is **only done on-demand**.
//// >
//// > Thus, for example:
//// >
//// > ```aiken
//// > rational.new(2, 3) != rational.new(4, 6)
//// > ```
//// >
//// > Comparing rational values should, therefore, only happen after reduction (see [reduce](#reduce)) or via the [compare](#compare) method.

use aiken/builtin
use aiken/collection/list
use aiken/math
use aiken/option

/// Opaque type used to ensure the sign of the Rational is managed strictly in the numerator.
pub opaque type Rational {
  numerator: Int,
  denominator: Int,
}

// ## Constructing

/// Create a new `Rational` from an `Int`.
///
/// ```aiken
/// Some(rational.from_int(14)) == rational.new(14, 1)
/// Some(rational.from_int(-5)) == rational.new(-5, 1)
/// Some(rational.from_int(0)) == rational.new(0, 1)
/// ```
pub fn from_int(numerator: Int) -> Rational {
  Rational { numerator, denominator: 1 }
}

test from_int_1() {
  and {
    (from_int(14) == ratio(14, 1))?,
    (from_int(-5) == ratio(-5, 1))?,
    (from_int(0) == ratio(0, 1))?,
  }
}

/// An unsafe constructor for `Rational` values. Assumes that the following invariants are
/// enforced:
///
/// - the denominator is positive (the sign is managed in the numerator);
/// - the denominator is not null.
///
/// This function is mainly used as a quick way to construct rationals from literal values.
fn ratio(numerator: Int, denominator: Int) -> Rational {
  Rational { numerator, denominator }
}

/// Make a `Rational` number from the ratio of two integers.
///
/// Returns `None` when the denominator is null.
///
/// ```aiken
/// rational.new(14, 42) == Some(r)
/// rational.new(14, 0) == None
/// ```
pub fn new(numerator: Int, denominator: Int) -> Option<Rational> {
  if denominator == 0 {
    None
  } else if denominator < 0 {
    Some(Rational { numerator: -numerator, denominator: -denominator })
  } else {
    Some(Rational { numerator, denominator })
  }
}

test new_1() {
  and {
    (new(2, 0) == None)?,
    (new(2, 3) == Some(ratio(2, 3)))?,
    (new(-2, 3) == Some(ratio(-2, 3)))?,
    (new(2, -3) == Some(ratio(-2, 3)))?,
    (new(2, 4) == Some(ratio(2, 4)))?,
    (new(-2, -3) == Some(ratio(2, 3)))?,
    (new(-2, -4) == Some(ratio(2, 4)))?,
  }
}

/// A null `Rational`.
pub const zero: Rational = Rational { numerator: 0, denominator: 1 }

test zero_1() {
  zero == ratio(0, 1)
}

// ## Inspecting

/// Get the denominator of a rational value.
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// rational.denominator(x) == 3
/// ```
pub fn denominator(self: Rational) -> Int {
  self.denominator
}

test denominator_1() {
  expect Some(x) = new(2, 3)
  expect Some(y) = new(-2, 3)
  expect Some(z) = new(2, -3)
  expect Some(w) = new(-2, -3)
  and {
    (denominator(x) == 3)?,
    (denominator(y) == 3)?,
    (denominator(z) == 3)?,
    (denominator(w) == 3)?,
  }
}

/// Get the numerator of a rational value.
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// rational.numerator(x) == 2
/// ```
pub fn numerator(self: Rational) -> Int {
  self.numerator
}

test numerator_1() {
  expect Some(x) = new(2, 3)
  expect Some(y) = new(-2, 3)
  expect Some(z) = new(2, -3)
  expect Some(w) = new(-2, -3)

  and {
    (numerator(x) == 2)?,
    (numerator(y) == -2)?,
    (numerator(z) == -2)?,
    (numerator(w) == 2)?,
  }
}

// ## Modifying

/// Absolute value of a `Rational`.
///
/// ```aiken
/// expect Some(x) = rational.new(3, 2)
/// expect Some(y) = rational.new(-3, 2)
///
/// rational.abs(x) == x
/// rational.abs(y) == x
/// ```
pub fn abs(self: Rational) -> Rational {
  let Rational { numerator: a_n, denominator: a_d } = self
  Rational { numerator: math.abs(a_n), denominator: a_d }
}

test abs_examples() {
  and {
    (abs(ratio(5, 2)) == ratio(5, 2))?,
    (abs(ratio(-5, 2)) == ratio(5, 2))?,
    (abs(ratio(5, 2)) == abs(ratio(-5, 2)))?,
  }
}

/// Change the sign of a `Rational`.
///
/// ```aiken
/// expect Some(x) = rational.new(3, 2)
/// expect Some(y) = rational.new(-3, 2)
///
/// rational.negate(x) == y
/// rational.negate(y) == x
/// ```
pub fn negate(a: Rational) -> Rational {
  let Rational { numerator: a_n, denominator: a_d } = a
  Rational { numerator: -a_n, denominator: a_d }
}

test negate_1() {
  and {
    (negate(ratio(5, 2)) == ratio(-5, 2))?,
    (negate(ratio(-5, 2)) == ratio(5, 2))?,
    (negate(negate(ratio(5, 2))) == ratio(5, 2))?,
  }
}

/// Reciprocal of a `Rational` number. That is, a new `Rational` where the
/// numerator and denominator have been swapped.
///
/// ```aiken
/// expect Some(x) = rational.new(2, 5)
/// rational.reciprocal(x) == rational.new(5, 2)
///
/// let y = rational.zero
/// rational.reciprocal(y) == None
/// ```
pub fn reciprocal(self: Rational) -> Option<Rational> {
  let Rational { numerator: a_n, denominator: a_d } = self
  if a_n < 0 {
    Some(Rational { numerator: -a_d, denominator: -a_n })
  } else if a_n > 0 {
    Some(Rational { numerator: a_d, denominator: a_n })
  } else {
    None
  }
}

test reciprocal_1() {
  and {
    (reciprocal(ratio(5, 2)) == new(2, 5))?,
    (reciprocal(ratio(-5, 2)) == new(-2, 5))?,
    (reciprocal(ratio(0, 2)) == None)?,
    (reciprocal(ratio(2, 3)) == new(3, 2))?,
    (reciprocal(ratio(-2, 3)) == new(-3, 2))?,
  }
}

/// Reduce a rational to its irreducible form. This operation makes the
/// numerator and denominator coprime.
///
/// ```aiken
/// expect Some(x) = rational.new(80, 200)
/// Some(rational.reduce(x)) == rational.new(2, 5)
/// ```
pub fn reduce(self: Rational) -> Rational {
  let Rational { numerator: a_n, denominator: a_d } = self
  let d = math.gcd(a_n, a_d)
  Rational { numerator: a_n / d, denominator: a_d / d }
}

test reduce_1() {
  and {
    (reduce(ratio(80, 200)) == ratio(2, 5))?,
    (reduce(ratio(-5, 1)) == ratio(-5, 1))?,
    (reduce(ratio(0, 3)) == ratio(0, 1))?,
  }
}

// ## Combining

// ### Arithmetic operations

/// Addition: sum of two rational values
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// expect Some(y) = rational.new(3, 4)
///
/// Some(rational.add(x, y)) == rational.new(17, 12)
/// ```
pub fn add(left: Rational, right: Rational) -> Rational {
  let Rational { numerator: a_n, denominator: a_d } = left
  let Rational { numerator: b_n, denominator: b_d } = right
  Rational { numerator: a_n * b_d + b_n * a_d, denominator: a_d * b_d }
}

test add_1() {
  add(ratio(2, 3), ratio(3, 4)) == ratio(17, 12)
}

test add_2() {
  add(ratio(-2, 3), ratio(3, 4)) == ratio(1, 12)
}

/// Division: quotient of two rational values. Returns `None` when the second
/// value is null.
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// expect Some(y) = rational.new(3, 4)
///
/// rational.div(x, y) == rational.new(8, 9)
/// ```
pub fn div(left: Rational, right: Rational) -> Option<Rational> {
  reciprocal(right) |> option.map(mul(left, _))
}

test div_1() {
  div(ratio(2, 3), ratio(3, 4)) == new(8, 9)
}

test div_2() {
  div(ratio(2, 3), ratio(-3, 4)) == new(-8, 9)
}

/// Multiplication: the product of two rational values.
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// expect Some(y) = rational.new(3, 4)
///
/// Some(rational.mul(x, y)) == rational.new(6, 12)
/// ```
pub fn mul(left: Rational, right: Rational) -> Rational {
  let Rational { numerator: a_n, denominator: a_d } = left
  let Rational { numerator: b_n, denominator: b_d } = right
  Rational { numerator: a_n * b_n, denominator: a_d * b_d }
}

test mul_1() {
  mul(ratio(2, 3), ratio(3, 4)) == ratio(6, 12)
}

test mul_2() {
  mul(ratio(-2, 3), ratio(-3, 4)) == ratio(6, 12)
}

test mul_3() {
  let result =
    ratio(2, 5)
      |> mul(ratio(1, 8))
      |> mul(ratio(3, 10))
      |> mul(ratio(21, 100))
      |> mul(ratio(3, 5))
      |> mul(ratio(2, 8))
      |> mul(ratio(4, 10))
      |> mul(ratio(22, 100))
      |> reduce

  result == ratio(2079, 50000000)
}

/// Subtraction: difference of two rational values
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// expect Some(y) = rational.new(3, 4)
///
/// Some(rational.sub(x, y)) == rational.new(-1, 12)
/// ```
pub fn sub(left: Rational, right: Rational) -> Rational {
  let Rational { numerator: a_n, denominator: a_d } = left
  let Rational { numerator: b_n, denominator: b_d } = right
  Rational { numerator: a_n * b_d - b_n * a_d, denominator: a_d * b_d }
}

test sub_1() {
  sub(ratio(2, 3), ratio(3, 4)) == ratio(-1, 12)
}

test sub_2() {
  sub(ratio(2, 3), ratio(-3, 4)) == ratio(17, 12)
}

test sub_3() {
  sub(ratio(-2, 3), ratio(3, 4)) == ratio(-17, 12)
}

// ### Ordering

/// Compare two rationals for an ordering. This is safe to use even for
/// non-reduced rationals.
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// expect Some(y) = rational.new(3, 4)
/// expect Some(z) = rational.new(4, 6)
///
/// compare(x, y) == Less
/// compare(y, x) == Greater
/// compare(x, x) == Equal
/// compare(x, z) == Equal
/// ```
pub fn compare(left: Rational, right: Rational) -> Ordering {
  let Rational { numerator: a_n, denominator: a_d } = left
  let Rational { numerator: b_n, denominator: b_d } = right

  let l = a_n * b_d
  let r = b_n * a_d

  if l < r {
    Less
  } else if l > r {
    Greater
  } else {
    Equal
  }
}

test compare_1() {
  expect Some(x) = new(2, 3)
  expect Some(y) = new(3, 4)
  expect Some(z) = new(4, 6)
  and {
    compare(x, y) == Less,
    compare(y, x) == Greater,
    compare(x, x) == Equal,
    compare(x, z) == Equal,
  }
}

/// Comparison of two rational values using a chosen heuristic. For example:
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// expect Some(y) = rational.new(3, 4)
///
/// rational.compare_with(x, >, y) == False
/// rational.compare_with(y, >, x) == True
/// rational.compare_with(x, >, x) == False
/// rational.compare_with(x, >=, x) == True
/// rational.compare_with(x, ==, x) == True
/// rational.compare_with(x, ==, y) == False
/// ```
pub fn compare_with(
  left: Rational,
  with: fn(Int, Int) -> Bool,
  right: Rational,
) -> Bool {
  let Rational { numerator: a_n, denominator: a_d } = left
  let Rational { numerator: b_n, denominator: b_d } = right
  with(a_n * b_d, b_n * a_d)
}

// TODO: Rewrite tests using binary-operator as first-class functions once aiken-lang/aiken#619 is merged.

test compare_with_eq() {
  let eq =
    compare_with(_, fn(l, r) { l == r }, _)

  expect Some(x) = new(2, 3)
  expect Some(y) = new(3, 4)

  !eq(x, y)? && !eq(y, x)? && eq(x, x)?
}

test compare_with_neq() {
  let neq =
    compare_with(_, fn(l, r) { l != r }, _)

  expect Some(x) = new(2, 3)
  expect Some(y) = new(3, 4)

  neq(x, y)? && neq(y, x)? && !neq(x, x)?
}

test compare_with_gte() {
  let gte =
    compare_with(_, fn(l, r) { l >= r }, _)

  expect Some(x) = new(2, 3)
  expect Some(y) = new(3, 4)

  !gte(x, y)? && gte(y, x)? && gte(x, x)?
}

test compare_with_gt() {
  let gt =
    compare_with(_, fn(l, r) { l > r }, _)

  expect Some(x) = new(2, 3)
  expect Some(y) = new(3, 4)

  !gt(x, y)? && gt(y, x)? && !gt(x, x)?
}

test compare_with_lte() {
  let lte =
    compare_with(_, fn(l, r) { l <= r }, _)

  expect Some(x) = new(2, 3)
  expect Some(y) = new(3, 4)

  lte(x, y)? && !lte(y, x)? && lte(x, x)?
}

test compare_with_lt() {
  let lt =
    compare_with(_, fn(l, r) { l < r }, _)

  expect Some(x) = new(2, 3)
  expect Some(y) = new(3, 4)

  lt(x, y)? && !lt(y, x)? && !lt(x, x)?
}

// ### Means

/// Calculate the arithmetic mean between two `Rational` values.
///
/// ```aiken
/// let x = rational.from_int(0)
/// let y = rational.from_int(1)
/// let z = rational.from_int(2)
///
/// expect Some(result) = rational.arithmetic_mean([x, y, z])
///
/// rational.compare(result, y) == Equal
/// ```
pub fn arithmetic_mean(self: List<Rational>) -> Option<Rational> {
  div(list.foldr(self, zero, add), from_int(list.length(self)))
}

test arithmetic_mean_1() {
  let x = ratio(1, 2)
  let y = ratio(1, 2)
  expect Some(z) = arithmetic_mean([x, y])
  reduce(z) == ratio(1, 2)
}

test arithmetic_mean_2() {
  let x = ratio(1, 1)
  let y = ratio(2, 1)
  expect Some(z) = arithmetic_mean([x, y])
  reduce(z) == ratio(3, 2)
}

test arithmetic_mean_3() {
  let xs =
    [
      ratio(1, 1),
      ratio(2, 1),
      ratio(3, 1),
      ratio(4, 1),
      ratio(5, 1),
      ratio(6, 1),
    ]
  expect Some(z) = arithmetic_mean(xs)
  reduce(z) == ratio(7, 2)
}

/// Calculate the geometric mean between two `Rational` values. This returns
/// either the exact result or the smallest integer nearest to the square root
/// for the numerator and denominator.
///
/// ```aiken
/// expect Some(x) = rational.new(1, 3)
/// expect Some(y) = rational.new(1, 6)
///
/// rational.geometric_mean(x, y) == rational.new(1, 4)
/// ```
pub fn geometric_mean(left: Rational, right: Rational) -> Option<Rational> {
  let Rational { numerator: a_n, denominator: a_d } = left
  let Rational { numerator: b_n, denominator: b_d } = right
  when math.sqrt(a_n * b_n) is {
    Some(numerator) ->
      when math.sqrt(a_d * b_d) is {
        Some(denominator) -> Some(Rational { numerator, denominator })
        None -> None
      }
    None -> None
  }
}

test geometric_mean1() {
  expect Some(x) = new(1, 2)
  expect Some(y) = new(1, 2)
  geometric_mean(x, y) == new(1, 2)
}

test geometric_mean2() {
  expect Some(x) = new(-1, 2)
  expect Some(y) = new(1, 2)
  geometric_mean(x, y) == None
}

test geometric_mean3() {
  expect Some(x) = new(1, 2)
  expect Some(y) = new(-1, 2)
  geometric_mean(x, y) == None
}

test geometric_mean4() {
  expect Some(x) = new(1, 3)
  expect Some(y) = new(1, 6)
  geometric_mean(x, y) == new(1, 4)
}

test geometric_mean5() {
  expect Some(x) = new(67, 2500)
  expect Some(y) = new(35331, 1000)
  expect Some(yi) = reciprocal(y)
  geometric_mean(x, yi) == new(258, 9398)
}

// ## Transforming

/// Returns the smallest `Int` not less than a given `Rational`
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// rational.ceil(x) == 1
///
/// expect Some(y) = rational.new(44, 14)
/// rational.ceil(y) == 4
///
/// expect Some(z) = rational.new(-14, 3)
/// rational.ceil(z) == -4
/// ```
pub fn ceil(self: Rational) -> Int {
  let Rational { numerator, denominator } = self
  if builtin.remainder_integer(numerator, denominator) > 0 {
    builtin.quotient_integer(numerator, denominator) + 1
  } else {
    builtin.quotient_integer(numerator, denominator)
  }
}

test ceil_1() {
  and {
    (ceil(ratio(13, 5)) == 3)?,
    (ceil(ratio(15, 5)) == 3)?,
    (ceil(ratio(16, 5)) == 4)?,
    (ceil(ratio(-3, 5)) == 0)?,
    (ceil(ratio(-5, 5)) == -1)?,
    (ceil(ratio(-14, 3)) == -4)?,
    (ceil(ratio(-14, 6)) == -2)?,
    (ceil(ratio(44, 14)) == 4)?,
  }
}

/// Returns the greatest `Int` no greater than a given `Rational`
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// rational.floor(x) == 0
///
/// expect Some(y) = rational.new(44, 14)
/// rational.floor(y) == 3
///
/// expect Some(z) = rational.new(-14, 3)
/// rational.floor(z) == -5
/// ```
pub fn floor(self: Rational) -> Int {
  let Rational { numerator: a_n, denominator: a_d } = self
  a_n / a_d
}

test floor_1() {
  and {
    (floor(ratio(5, 2)) == 2)?,
    (floor(ratio(5, 3)) == 1)?,
    (floor(ratio(5, 4)) == 1)?,
    (floor(ratio(5, 5)) == 1)?,
    (floor(ratio(5, 6)) == 0)?,
    (floor(ratio(8, 3)) == 2)?,
    (floor(ratio(-14, 3)) == -5)?,
  }
}

/// Computes the rational number x raised to the power y. Returns `None` for
/// invalid exponentiation.
///
/// ```aiken
/// expect Some(x) = rational.new(50, 2500)
/// rational.reduce(rational.pow(x, 3)) == rational.new(1, 125000)
///
/// expect Some(x) = rational.new(50, 2500)
/// rational.reduce(rational.pow(x, -3)) == rational.new(125000, 1)
/// ```
pub fn pow(x: Rational, y: Int) -> Option<Rational> {
  let Rational { numerator: a, denominator: b } = x

  if a == 0 && y <= 0 {
    None
  } else if y > 0 {
    Some(Rational { numerator: math.pow(a, y), denominator: math.pow(b, y) })
  } else if y < 0 {
    Some(Rational { numerator: math.pow(b, -y), denominator: math.pow(a, -y) })
  } else {
    Some(Rational { numerator: 1, denominator: 1 })
  }
}

test pow_negative_exponent_non_zero_fraction() {
  expect Some(base) = new(50, 2500)
  expect Some(calculated_result) = pow(base, -3)
  expect Some(expected_result) = new(125000, 1)
  reduce(calculated_result) == expected_result
}

test pow_positive_exponent() {
  expect Some(base) = new(50, 2500)
  expect Some(calculated_result) = pow(base, 3)
  expect Some(expected_result) = new(1, 125000)
  reduce(calculated_result) == expected_result
}

test pow_exponent_zero() {
  expect Some(base) = new(50, 2500)
  pow(base, 0) == new(1, 1)
}

test pow_rational_zero_exponent_zero() {
  expect Some(base) = new(0, 1)
  pow(base, 0) == None
}

/// Returns the proper fraction of a given `Rational` `r`. That is, a 2-tuple of
/// an `Int` and `Rational` (n, f) such that:
///
/// - `r = n + f`;
/// - `n` and `f` have the same sign as `r`;
/// - `f` has an absolute value less than 1.
pub fn proper_fraction(self: Rational) -> (Int, Rational) {
  let Rational { numerator, denominator } = self
  (
    builtin.quotient_integer(numerator, denominator),
    Rational {
      numerator: builtin.remainder_integer(numerator, denominator),
      denominator,
    },
  )
}

test proper_fraction_1() {
  let r = ratio(10, 7)
  let (n, f) = proper_fraction(r)
  and {
    (n == 1)?,
    (f == ratio(3, 7))?,
    (r == add(from_int(n), f))?,
  }
}

test proper_fraction_2() {
  let r = ratio(-10, 7)
  let (n, f) = proper_fraction(r)
  and {
    (n == -1)?,
    (f == ratio(-3, 7))?,
    (r == add(from_int(n), f))?,
  }
}

test proper_fraction_3() {
  let r = ratio(4, 2)
  let (n, f) = proper_fraction(r)
  and {
    (n == 2)?,
    (f == ratio(0, 2))?,
    (r == add(from_int(n), f))?,
  }
}

/// Round the argument to the nearest whole number. If the argument is
/// equidistant between two values, the greater value is returned (it
/// rounds half towards positive infinity).
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// rational.round(x) == 1
///
/// expect Some(y) = rational.new(3, 2)
/// rational.round(y) == 2
///
/// expect Some(z) = rational.new(-3, 2)
/// rational.round(z) == -1
/// ```
///
/// > [!CAUTION]
/// > This behaves differently than _Haskell_. If you're coming from `PlutusTx`, beware that in Haskell, rounding on equidistant values depends on the whole number being odd or even.
/// > If you need this behaviour, use [`round_even`](#round_even).
pub fn round(self: Rational) -> Int {
  let (n, f) = proper_fraction(self)

  let is_negative = f.numerator < 0

  when compare(abs(f), ratio(1, 2)) is {
    Less -> n
    Equal ->
      if is_negative {
        n
      } else {
        n + 1
      }
    Greater ->
      if is_negative {
        n - 1
      } else {
        n + 1
      }
  }
}

test round_1() {
  and {
    (round(ratio(10, 7)) == 1)?,
    (round(ratio(11, 7)) == 2)?,
    (round(ratio(3, 2)) == 2)?,
    (round(ratio(5, 2)) == 3)?,
    (round(ratio(-3, 2)) == -1)?,
    (round(ratio(-2, 3)) == -1)?,
    (round(ratio(-10, 7)) == -1)?,
    (round(ratio(4, 2)) == 2)?,
  }
}

/// Round the argument to the nearest whole number. If the argument is
/// equidistant between two values, it returns the value that is even (it
/// rounds half to even, also known as 'banker's rounding').
///
/// ```aiken
/// expect Some(w) = rational.new(2, 3)
/// rational.round_even(w) == 1
///
/// expect Some(x) = rational.new(3, 2)
/// rational.round_even(x) == 2
///
/// expect Some(y) = rational.new(5, 2)
/// rational.round_even(y) == 2
///
/// expect Some(y) = rational.new(-3, 2)
/// rational.round_even(y) == -2
/// ```
pub fn round_even(self: Rational) -> Int {
  let (n, f) = proper_fraction(self)

  let m =
    when compare(f, ratio(0, 1)) is {
      Less -> -1
      _ -> 1
    }

  let is_even = n % 2 == 0

  when compare(abs(f), ratio(1, 2)) is {
    Less -> n
    Equal ->
      if is_even {
        n
      } else {
        n + m
      }
    Greater -> n + m
  }
}

test round_even_1() {
  and {
    (round_even(ratio(10, 7)) == 1)?,
    (round_even(ratio(11, 7)) == 2)?,
    (round_even(ratio(3, 2)) == 2)?,
    (round_even(ratio(5, 2)) == 2)?,
    (round_even(ratio(-3, 2)) == -2)?,
    (round_even(ratio(-2, 3)) == -1)?,
    (round_even(ratio(-10, 7)) == -1)?,
    (round_even(ratio(4, 2)) == 2)?,
  }
}

/// Returns the nearest `Int` between zero and a given `Rational`.
///
/// ```aiken
/// expect Some(x) = rational.new(2, 3)
/// rational.truncate(x) == 0
///
/// expect Some(y) = rational.new(44, 14)
/// rational.truncate(y) == 3
///
/// expect Some(z) = rational.new(-14, 3)
/// rational.truncate(z) == -4
/// ```
pub fn truncate(self: Rational) -> Int {
  let Rational { numerator: a_n, denominator: a_d } = self
  builtin.quotient_integer(a_n, a_d)
}

test truncate_1() {
  and {
    (truncate(ratio(5, 2)) == 2)?,
    (truncate(ratio(5, 3)) == 1)?,
    (truncate(ratio(5, 4)) == 1)?,
    (truncate(ratio(5, 5)) == 1)?,
    (truncate(ratio(5, 6)) == 0)?,
    (truncate(ratio(8, 3)) == 2)?,
    (truncate(ratio(-14, 3)) == -4)?,
  }
}



================================================
FILE: lib/aiken/primitive/bytearray.ak
================================================
use aiken/builtin
use aiken/math
use aiken/option

pub type Byte =
  Int

// ## Constructing

/// Encode an integer value as a Big-Endian (most-significant bytes first) `ByteArray`.
/// The size is the expected size in number of bytes.
///
/// > [!IMPORTANT]
/// > This function fails (i.e. halts the program) if the value cannot fit in the given size. When the
/// > size is _too large_, the array is left-padded with zeroes.
///
/// ```aiken
/// bytearray.from_int_big_endian(1_000_000, 3) == #"0f4240"
/// bytearray.from_int_big_endian(1_000_000, 5) == #"00000f4240"
/// bytearray.from_int_big_endian(0, 8) == #"0000000000000000"
/// bytearray.from_int_big_endian(1_000_000, 1) => ðŸ’¥
/// ```
pub fn from_int_big_endian(self: Int, size: Int) -> ByteArray {
  builtin.integer_to_bytearray(True, size, self)
}

test from_int_big_endian_1() {
  from_int_big_endian(1_000_000, 3) == #"0f4240"
}

test from_int_big_endian_2() {
  from_int_big_endian(1_000_000, 5) == #"00000f4240"
}

test from_int_big_endian_3() {
  from_int_big_endian(0, 8) == #"0000000000000000"
}

test from_int_big_endian_4() fail {
  from_int_big_endian(1_000_000, 1) == #"40"
}

/// Encode an integer value as a Little-Endian (least-significant bytes first) `ByteArray`.
/// The size is the expected size in number of bytes.
///
/// > [!IMPORTANT]
/// > This function fails (i.e. halts the program) if the value cannot fit in the given size. When the
/// > size is _too large_, the array is right-padded with zeroes.
///
/// ```aiken
/// bytearray.from_int_little_endian(1_000_000, 3) == #"40420f"
/// bytearray.from_int_little_endian(1_000_000, 5) == #"40420f0000"
/// bytearray.from_int_little_endian(0, 8) == #"0000000000000000"
/// bytearray.from_int_little_endian(1_000_000, 1) => ðŸ’¥
/// ```
pub fn from_int_little_endian(self: Int, size: Int) -> ByteArray {
  builtin.integer_to_bytearray(False, size, self)
}

test from_int_little_endian_1() {
  from_int_little_endian(1_000_000, 3) == #"40420f"
}

test from_int_little_endian_2() {
  from_int_little_endian(1_000_000, 5) == #"40420f0000"
}

test from_int_little_endian_3() {
  from_int_little_endian(0, 8) == #"0000000000000000"
}

test from_int_little_endian_4() fail {
  from_int_little_endian(1_000_000, 1) == #"40"
}

/// Convert a `String` into a `ByteArray`.
///
/// ```aiken
/// bytearray.from_string(@"ABC") == #"414243"
/// ```
pub fn from_string(str: String) -> ByteArray {
  builtin.encode_utf8(str)
}

test from_string_1() {
  from_string(@"") == ""
}

test from_string_2() {
  from_string(@"ABC") == #"414243"
}

/// Add a byte element in front of a `ByteArray`. When the given byte is
/// greater than 255, it wraps-around. **PlutusV2 behavior** So 256 is mapped to 0, 257 to 1, and so
/// forth.
/// In PlutusV3 this will error instead of wrapping around.
///
/// ```aiken
/// bytearray.push(#"", 0) == #"00"
/// bytearray.push(#"0203", 1) == #"010203"
/// bytearray.push(#"0203", 257) == #"010203"
/// ```
pub fn push(self: ByteArray, byte: Byte) -> ByteArray {
  builtin.cons_bytearray(byte, self)
}

test push_1() {
  push(#[], 0) == #[0]
}

test push_2() {
  push(#[2, 3], 1) == #[1, 2, 3]
}

test push_3() fail {
  let x = 257
  push(#[2, 3], x) == #[1, 2, 3]
}

// ## Inspecting

/// Get the `Byte` at the given index, or crash.
///
/// > [!WARNING]
/// > This functions fails (i.e. halts the program) if there's no byte at the given index.
pub fn at(self: ByteArray, index: Int) -> Byte {
  builtin.index_bytearray(self, index)
}

/// Search the start and end positions of a sub-array in a `ByteArray`.
///
/// ```aiken
/// bytearray.index_of("Hello, World!", "World") == Some((7, 11))
/// bytearray.index_of("Hello, World!", "foo") == None
/// bytearray.index_of("Hello, World!", "!") == Some((12, 12))
/// bytearray.index_of("Hello, World!", "o") == Some((4, 4))
/// bytearray.index_of("Hello, World!", "Hello, World!") == Some((0, 12))
/// ```
pub fn index_of(self: ByteArray, bytes: ByteArray) -> Option<(Int, Int)> {
  let offset = length(bytes)

  do_index_of(self, bytes, 0, offset, length(self))
    |> option.map(fn(ix) { (ix, ix + offset - 1) })
}

fn do_index_of(
  self: ByteArray,
  bytes: ByteArray,
  cursor: Int,
  offset: Int,
  size: Int,
) -> Option<Int> {
  if cursor + offset > size {
    None
  } else {
    if builtin.slice_bytearray(cursor, offset, self) == bytes {
      Some(cursor)
    } else {
      do_index_of(self, bytes, cursor + 1, offset, size)
    }
  }
}

test index_of_1() {
  index_of("Hello, World!", "World") == Some((7, 11))
}

test index_of_2() {
  index_of("Hello, World!", "foo") == None
}

test index_of_3() {
  index_of("Hello, World!", "!") == Some((12, 12))
}

test index_of_4() {
  index_of("Hello, World!", "o") == Some((4, 4))
}

test index_of_5() {
  index_of("Hello, World!", "Hello, World!") == Some((0, 12))
}

/// Returns `True` when the given `ByteArray` is empty.
///
/// ```aiken
/// bytearray.is_empty(#"") == True
/// bytearray.is_empty(#"00ff") == False
/// ```
pub fn is_empty(self: ByteArray) -> Bool {
  builtin.length_of_bytearray(self) == 0
}

test is_empty_1() {
  is_empty(#"") == True
}

test is_empty_2() {
  is_empty(#"01") == False
}

/// Returns the number of bytes in a `ByteArray`.
///
/// ```aiken
/// bytearray.length(#[1, 2, 3]) == 3
/// ```
pub fn length(self: ByteArray) -> Int {
  builtin.length_of_bytearray(self)
}

test length_1() {
  length(#"") == 0
}

test length_2() {
  length(#"010203") == 3
}

/// Checks whether a bit (Most-Significant-Bit first) is set in the given 'ByteArray'.
///
/// For example, consider the following bytearray: `#"8b765f"`. It can also be written as the
/// following bits sequence:
///
/// `8`    | `b`    | `7`    | `6`    | `5`    | `f`
/// ---    | ---    | ---    | ---    | ---    | ---
/// `1000` | `1011` | `0111` | `0110` | `0101` | `1111`
///
/// And thus, we have:
///
/// ```aiken
/// test_bit(#"8b765f", 0) == True
/// test_bit(#"8b765f", 1) == False
/// test_bit(#"8b765f", 2) == False
/// test_bit(#"8b765f", 3) == False
/// test_bit(#"8b765f", 7) == True
/// test_bit(#"8b765f", 8) == False
/// test_bit(#"8b765f", 20) == True
/// test_bit(#"8b765f", 21) == True
/// test_bit(#"8b765f", 22) == True
/// test_bit(#"8b765f", 23) == True
/// ```
pub fn test_bit(self: ByteArray, ix: Int) -> Bool {
  builtin.less_than_equals_bytearray(
    #[128],
    builtin.cons_bytearray(
      builtin.index_bytearray(self, ix / 8) * math.pow2(ix % 8) % 256,
      "",
    ),
  )
}

test test_bit_0() {
  test_bit(#"8b765f", 0)
}

test test_bit_1() {
  !test_bit(#"8b765f", 1)
}

test test_bit_2() {
  !test_bit(#"8b765f", 2)
}

test test_bit_3() {
  !test_bit(#"8b765f", 3)
}

test test_bit_7() {
  test_bit(#"8b765f", 7)
}

test test_bit_8() {
  !test_bit(#"8b765f", 8)
}

test test_bit_20_21_22_23() {
  and {
    test_bit(#"8b765f", 20),
    test_bit(#"8b765f", 21),
    test_bit(#"8b765f", 22),
    test_bit(#"8b765f", 23),
  }
}

// ## Modifying

/// Returns the suffix of a `ByteArray` after `n` elements.
///
/// ```aiken
/// bytearray.drop(#[1, 2, 3], n: 2) == #[3]
/// ```
pub fn drop(self: ByteArray, n: Int) -> ByteArray {
  builtin.slice_bytearray(n, builtin.length_of_bytearray(self) - n, self)
}

test drop_1() {
  let x = #"01020304050607"
  drop(x, 2) == #"0304050607"
}

test drop_2() {
  let x = #"01020304050607"
  drop(x, 0) == x
}

test drop_3() {
  let x = #"01"
  drop(x, 1) == #""
}

test drop_4() {
  let x = #""
  drop(x, 2) == #""
}

/// Extract a `ByteArray` as a slice of another `ByteArray`.
///
/// Indexes are 0-based and inclusive.
///
/// ```aiken
/// bytearray.slice(#[0, 1, 2, 3, 4, 5, 6], start: 1, end: 3) == #[1, 2, 3]
/// ```
pub fn slice(self: ByteArray, start: Int, end: Int) -> ByteArray {
  builtin.slice_bytearray(start, end - start + 1, self)
}

test slice_1() {
  slice(#"", 1, 2) == #""
}

test slice_2() {
  slice(#"010203", 1, 2) == #"0203"
}

test slice_3() {
  slice(#"010203", 0, 42) == #"010203"
}

test slice_4() {
  slice(#[0, 1, 2, 3, 4], 0, 3) == #[0, 1, 2, 3]
}

test slice_5() {
  slice(#[0, 1, 2, 3, 4], 1, 2) == #[1, 2]
}

/// Returns the n-length prefix of a `ByteArray`.
///
/// ```aiken
/// bytearray.take(#[1, 2, 3], n: 2) == #[1, 2]
/// ```
pub fn take(self: ByteArray, n: Int) -> ByteArray {
  builtin.slice_bytearray(0, n, self)
}

test take_1() {
  let x = #"01020304050607"
  take(x, 2) == #"0102"
}

test take_2() {
  let x = #"01020304050607"
  take(x, 0) == #""
}

test take_3() {
  let x = #"01"
  take(x, 1) == x
}

test take_4() {
  let x = #"010203"
  take(x, 0) == #""
}

// ## Combining

/// Combine two `ByteArray` together.
///
/// ```aiken
/// bytearray.concat(left: #[1, 2, 3], right: #[4, 5, 6]) == #[1, 2, 3, 4, 5, 6]
/// ```
pub fn concat(left: ByteArray, right: ByteArray) -> ByteArray {
  builtin.append_bytearray(left, right)
}

test concat_1() {
  concat(#"", #"") == #""
}

test concat_2() {
  concat(#"", #"01") == #"01"
}

test concat_3() {
  concat(#"0102", #"") == #"0102"
}

test concat_4() {
  concat(#"0102", #"0304") == #"01020304"
}

/// Compare two bytearrays lexicographically.
///
/// ```aiken
/// bytearray.compare(#"00", #"FF") == Less
/// bytearray.compare(#"42", #"42") == Equal
/// bytearray.compare(#"FF", #"00") == Greater
/// ```
pub fn compare(left: ByteArray, right: ByteArray) -> Ordering {
  if builtin.less_than_bytearray(left, right) {
    Less
  } else if builtin.equals_bytearray(left, right) {
    Equal
  } else {
    Greater
  }
}

// ## Transforming

/// Left-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.
///
/// ```aiken
/// bytearray.foldl(#"acab", 0, fn(byte, acc) { acc * 256 + byte }) == 44203
/// bytearray.foldl(#[1, 2, 3], #"", flip(bytearray.push)) == #[3, 2, 1]
/// ```
pub fn foldl(
  self: ByteArray,
  zero: result,
  with: fn(Int, result) -> result,
) -> result {
  do_foldl(self, zero, builtin.length_of_bytearray(self), 0, with)
}

fn do_foldl(
  self: ByteArray,
  zero: result,
  len: Int,
  cursor: Int,
  with: fn(Int, result) -> result,
) -> result {
  if cursor == len {
    zero
  } else {
    do_foldl(
      self,
      with(builtin.index_bytearray(self, cursor), zero),
      len,
      cursor + 1,
      with,
    )
  }
}

test foldl_1() {
  foldl(#[], 42, fn(byte, acc) { byte + acc }) == 42
}

test foldl_2() {
  foldl(#"acab", 0, fn(byte, acc) { acc * 256 + byte }) == 44203
}

test foldl_3() {
  foldl(
    #"356cf088720a169dae0ce0bb1df8588944389fa43322f0d6ef4ed8c069bfd405",
    0,
    fn(byte, acc) { acc * 256 + byte },
  ) == 24165060555594911913195642527692216679757672038384202527929620681761931383813
}

test foldl_4() {
  foldl(#[1, 2, 3, 4, 5], #"", flip(push)) == #[5, 4, 3, 2, 1]
}

/// Right-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.
///
/// ```aiken
/// bytearray.foldr(#"acab", 0, fn(byte, acc) { acc * 256 + byte }) == 43948
/// bytearray.foldr(#[1, 2, 3], #"", flip(bytearray.push)) == #[1, 2, 3]
/// ```
pub fn foldr(
  self: ByteArray,
  zero: result,
  with: fn(Int, result) -> result,
) -> result {
  do_foldr(self, zero, builtin.length_of_bytearray(self) - 1, with)
}

fn do_foldr(
  self: ByteArray,
  zero: result,
  cursor: Int,
  with: fn(Int, result) -> result,
) -> result {
  if cursor < 0 {
    zero
  } else {
    do_foldr(
      self,
      with(builtin.index_bytearray(self, cursor), zero),
      cursor - 1,
      with,
    )
  }
}

test foldr_1() {
  foldr(#[], 42, fn(byte, acc) { byte + acc }) == 42
}

test foldr_2() {
  foldr(#"acab", 0, fn(byte, acc) { acc * 256 + byte }) == 43948
}

test foldr_3() {
  foldr(#[1, 2, 3, 4, 5], #"", flip(push)) == #[1, 2, 3, 4, 5]
}

/// Reduce bytes in a ByteArray from left to right using the accumulator as left operand.
/// Said differently, this is [`foldl`](#foldl) with callback arguments swapped.
///
/// ```aiken
/// bytearray.reduce(#[1,2,3], #[], bytearray.push) == #[3, 2, 1]
/// ```
pub fn reduce(
  self: ByteArray,
  zero: result,
  with: fn(result, Int) -> result,
) -> result {
  foldl(self, zero, flip(with))
}

test reduce_1() {
  reduce(#[], #[], push) == #[]
}

test reduce_2() {
  reduce(#[1, 2, 3], #[], push) == #[3, 2, 1]
}

/// Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.
///
/// ```aiken
/// bytearray.to_int_big_endian(#"0f4240") == 1_000_000
/// bytearray.to_int_big_endian(#"00000f4240") == 1_000_000
/// bytearray.to_int_big_endian(#"0000000000000000") == 0
/// ```
pub fn to_int_big_endian(self: ByteArray) -> Int {
  builtin.bytearray_to_integer(True, self)
}

test to_int_big_endian_1() {
  to_int_big_endian(#"0f4240") == 1_000_000
}

test to_int_big_endian_2() {
  to_int_big_endian(#"00000f4240") == 1_000_000
}

test to_int_big_endian_3() {
  to_int_big_endian(#"0000000000000000") == 0
}

/// Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.
///
/// ```aiken
/// bytearray.to_int_big_endian(#"40420f") == 1_000_000
/// bytearray.to_int_big_endian(#"40420f0000") == 1_000_000
/// bytearray.to_int_big_endian(#"0000000000000000") == 0
/// ```
pub fn to_int_little_endian(self: ByteArray) -> Int {
  builtin.bytearray_to_integer(False, self)
}

test to_int_little_endian_1() {
  to_int_little_endian(#"40420f") == 1_000_000
}

test to_int_little_endian_2() {
  to_int_little_endian(#"40420f0000") == 1_000_000
}

test to_int_little_endian_3() {
  to_int_little_endian(#"0000000000000000") == 0
}

/// Convert a `ByteArray` into a `String`.
///
/// > [!WARNING]
/// > This functions fails (i.e. halts the program) if the underlying `ByteArray` isn't UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.
/// >
/// > For converting arbitrary `ByteArray`s, use [bytearray.to_hex](#to_hex).
///
/// ```aiken
/// bytearray.to_string(#"414243") == "ABC"
/// bytearray.to_string(some_hash) => ðŸ’¥
/// ```
pub fn to_string(self: ByteArray) -> String {
  builtin.decode_utf8(self)
}

test to_string_1() {
  to_string("") == @""
}

test to_string_2() {
  to_string("ABC") == @"ABC"
}

/// Encode a `ByteArray` as a hexidecimal `String`.
///
/// ```aiken
/// bytearray.to_hex("Hello world!") == @"48656c6c6f20776f726c6421"
/// ```
pub fn to_hex(self: ByteArray) -> String {
  self
    |> encode_base16(builtin.length_of_bytearray(self) - 1, "")
    |> builtin.decode_utf8
}

test to_hex_1() {
  to_hex("Hello world!") == @"48656C6C6F20776F726C6421"
}

test to_hex_2() {
  to_hex("The quick brown fox jumps over the lazy dog") == @"54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67"
}

/// Checks whether a `ByteArray` starts with a given prefix.
///
/// ```aiken
/// bytearray.starts_with("Hello, World!", prefix: "Hello") == True
/// bytearray.starts_with("", prefix: "") == True
/// bytearray.starts_with("Hello", prefix: "Hello, World!") == False
/// ```
pub fn starts_with(self: ByteArray, prefix: ByteArray) -> Bool {
  let prefix_length = length(prefix)
  if length(self) < prefix_length {
    False
  } else {
    take(self, prefix_length) == prefix
  }
}

test starts_with_1() {
  starts_with("", "")
}

test starts_with_2() {
  starts_with("Hello, World!", "Hello, World!")
}

test starts_with_3() {
  !starts_with("Hello, World!", "hello")
}

test starts_with_4() {
  !starts_with("", "World")
}

test starts_with_5() {
  starts_with("Hello, World", "Hello")
}

test starts_with_6() {
  !starts_with("foo", "foo_")
}

pub fn and_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {
  builtin.and_bytearray(pad_end, left, right)
}

pub fn or_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {
  builtin.or_bytearray(pad_end, left, right)
}

pub fn xor_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {
  builtin.xor_bytearray(pad_end, left, right)
}



================================================
FILE: lib/aiken/primitive/int.ak
================================================
use aiken/builtin.{bytearray_to_integer, decode_utf8}
use aiken/math
use aiken/option
use aiken/primitive/bytearray

// ## Combining

/// Compare two integers.
///
/// ```aiken
/// int.compare(14, 42) == Less
/// int.compare(14, 14) == Equal
/// int.compare(42, 14) == Greater
/// ```
pub fn compare(left: Int, right: Int) -> Ordering {
  if left < right {
    Less
  } else if left > right {
    Greater
  } else {
    Equal
  }
}

// ## Transforming

/// Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.
///
/// ```aiken
/// int.from_bytearray_big_endian(#"0f4240") == 1_000_000
/// int.from_bytearray_big_endian(#"00000f4240") == 1_000_000
/// int.from_bytearray_big_endian(#"0000000000000000") == 0
/// ```
pub fn from_bytearray_big_endian(self: ByteArray) -> Int {
  bytearray_to_integer(True, self)
}

test from_bytearray_big_endian_1() {
  from_bytearray_big_endian(#"0f4240") == 1_000_000
}

test from_bytearray_big_endian_2() {
  from_bytearray_big_endian(#"00000f4240") == 1_000_000
}

test from_bytearray_big_endian_3() {
  from_bytearray_big_endian(#"0000000000000000") == 0
}

/// Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.
///
/// ```aiken
/// int.from_bytearray_big_endian(#"40420f") == 1_000_000
/// int.from_bytearray_big_endian(#"40420f0000") == 1_000_000
/// int.from_bytearray_big_endian(#"0000000000000000") == 0
/// ```
pub fn from_bytearray_little_endian(self: ByteArray) -> Int {
  bytearray_to_integer(False, self)
}

test from_bytearray_little_endian_1() {
  from_bytearray_little_endian(#"40420f") == 1_000_000
}

test from_bytearray_little_endian_2() {
  from_bytearray_little_endian(#"40420f0000") == 1_000_000
}

test from_bytearray_little_endian_3() {
  from_bytearray_little_endian(#"0000000000000000") == 0
}

/// Parse an integer from a utf-8 encoded `ByteArray`, when possible.
///
/// ```aiken
/// int.from_utf8("14") == Some(14)
/// int.from_utf8("-42") == Some(-42)
/// int.from_utf8("007") == Some(7)
/// int.from_utf8("foo") == None
/// int.from_utf8("1.0") == None
/// int.from_utf8("1-2") == None
/// ```
pub fn from_utf8(bytes: ByteArray) -> Option<Int> {
  bytes
    |> bytearray.foldr(
        Some((0, 0)),
        fn(byte, st) {
          when st is {
            None -> None
            Some((n, e)) ->
              if byte < 48 || byte > 57 {
                if byte == 45 {
                  Some((-n, 0))
                } else {
                  None
                }
              } else if n < 0 {
                None
              } else {
                let digit = byte - 48
                Some((n + digit * math.pow(10, e), e + 1))
              }
          }
        },
      )
    |> option.map(fn(tuple) { tuple.1st })
}

test from_utf8_1() {
  from_utf8("0017") == Some(17)
}

test from_utf8_2() {
  from_utf8("42") == Some(42)
}

test from_utf8_3() {
  from_utf8("1337") == Some(1337)
}

test from_utf8_4() {
  from_utf8("-14") == Some(-14)
}

test from_utf8_5() {
  from_utf8("foo") == None
}

test from_utf8_6() {
  from_utf8("1-2") == None
}

/// Convert an `Int` to its `String` representation.
///
/// ```aiken
/// int.to_string(42) == @"42"
/// ```
pub fn to_string(n: Int) -> String {
  diagnostic(n, "") |> decode_utf8
}

test to_string_1() {
  to_string(0) == @"0"
}

test to_string_2() {
  to_string(5) == @"5"
}

test to_string_3() {
  to_string(42) == @"42"
}

test to_string_4() {
  to_string(200) == @"200"
}



================================================
FILE: lib/aiken/primitive/string.ak
================================================
use aiken/builtin.{
  append_bytearray, append_string, decode_utf8, encode_utf8, length_of_bytearray,
}

// ## Constructing

/// Convert a `ByteArray` into a `String`
///
/// > [!WARNING]
/// > This functions fails if the underlying `ByteArray` isn't UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.
/// >
/// > For converting arbitrary `ByteArray`s, use [bytearray.to_hex](./bytearray.html#to_hex).
///
/// ```aiken
/// string.from_bytearray("foo") == @"foo"
/// string.from_bytearray(#"666f6f") == @"foo"
/// string.from_bytearray(some_hash) -> fail
/// ```
pub fn from_bytearray(bytes: ByteArray) -> String {
  decode_utf8(bytes)
}

test from_bytearray_1() {
  from_bytearray(#[]) == @""
}

test from_bytearray_2() {
  from_bytearray(#[65, 66, 67]) == @"ABC"
}

test from_bytearray_3() {
  from_bytearray("ABC") == @"ABC"
}

/// Convert an `Int` to its `String` representation.
///
/// ```aiken
/// string.from_int(42) == @"42"
/// ```
pub fn from_int(n: Int) -> String {
  diagnostic(n, "") |> decode_utf8
}

test from_int_1() {
  from_int(0) == @"0"
}

test from_int_2() {
  from_int(5) == @"5"
}

test from_int_3() {
  from_int(42) == @"42"
}

test from_int_4() {
  from_int(200) == @"200"
}

// ## Combining

/// Combine two `String` together.
///
/// ```aiken
/// string.concat(left: @"Hello", right: @", World!") == @"Hello, World!"
/// ```
pub fn concat(left: String, right: String) -> String {
  append_string(left, right)
}

test concat_1() {
  concat(@"", @"") == @""
}

test concat_2() {
  concat(@"", @"foo") == concat(@"foo", @"")
}

test concat_3() {
  concat(left: @"Hello", right: @", World!") == @"Hello, World!"
}

/// Join a list of strings, separated by a given _delimiter_.
///
/// ```aiken
/// string.join([], @"+") == @""
/// string.join([@"a", @"b", @"c"], @",") == @"a,b,c"
/// ```
pub fn join(list: List<String>, delimiter: String) -> String {
  do_join(list, encode_utf8(delimiter), #"")
    |> decode_utf8
}

fn do_join(xs, delimiter, bytes) {
  when xs is {
    [] -> bytes
    [x, ..rest] ->
      do_join(
        rest,
        delimiter,
        if length_of_bytearray(bytes) == 0 {
          encode_utf8(x)
        } else {
          append_bytearray(bytes, append_bytearray(delimiter, encode_utf8(x)))
        },
      )
  }
}

test join_1() {
  join([], @",") == @""
}

test join_2() {
  join([@"a", @"b", @"c"], @",") == @"a,b,c"
}

// ## Transforming

/// Convert a `String` into a `ByteArray`
///
/// ```aiken
/// string.to_bytearray(@"foo") == "foo"
/// ```
pub fn to_bytearray(self: String) -> ByteArray {
  encode_utf8(self)
}

test to_bytearray_1() {
  to_bytearray(@"") == ""
}

test to_bytearray_2() {
  to_bytearray(@"ABC") == #[65, 66, 67]
}

test to_bytearray_3() {
  to_bytearray(@"ABC") == "ABC"
}



================================================
FILE: lib/cardano/address.ak
================================================
use aiken/crypto.{
  Blake2b_224, Hash, Script, ScriptHash, VerificationKey, VerificationKeyHash,
}

/// A general structure for representing an on-chain `Credential`.
///
/// Credentials are always one of two kinds: a direct public/private key
/// pair, or a script (native or Plutus).
pub type Credential {
  VerificationKey(VerificationKeyHash)
  Script(ScriptHash)
}

// ## Constructing

/// A Cardano `Address` typically holding one or two credential references.
///
/// Note that legacy bootstrap addresses (a.k.a. 'Byron addresses') are
/// completely excluded from Plutus contexts. Thus, from an on-chain
/// perspective only exists addresses of type 00, 01, ..., 07 as detailed
/// in [CIP-0019 :: Shelley Addresses](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#shelley-addresses).
pub type Address {
  payment_credential: PaymentCredential,
  stake_credential: Option<StakeCredential>,
}

/// Smart-constructor for an [Address](#Address) from a [script](#Script) hash. The address has no delegation rights whatsoever.
pub fn from_script(script: Hash<Blake2b_224, Script>) -> Address {
  Address { payment_credential: Script(script), stake_credential: None }
}

/// Smart-constructor for an [Address](#Address) from a [verification key](#VerificationKey) hash. The resulting address has no delegation rights whatsoever.
pub fn from_verification_key(vk: Hash<Blake2b_224, VerificationKey>) -> Address {
  Address { payment_credential: VerificationKey(vk), stake_credential: None }
}

/// Set (or reset) the delegation part of an [Address](#Address) using a [verification key](#VerificationKey) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).
pub fn with_delegation_key(
  self: Address,
  vk: Hash<Blake2b_224, VerificationKey>,
) -> Address {
  Address {
    payment_credential: self.payment_credential,
    stake_credential: Some(Inline(VerificationKey(vk))),
  }
}

/// Set (or reset) the delegation part of an [Address](#Address) using a [script](#Script) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).
pub fn with_delegation_script(
  self: Address,
  script: Hash<Blake2b_224, Script>,
) -> Address {
  Address {
    payment_credential: self.payment_credential,
    stake_credential: Some(Inline(Script(script))),
  }
}

/// Represent a type of object that can be represented either inline (by hash)
/// or via a reference (i.e. a pointer to an on-chain location).
///
/// This is mainly use for capturing pointers to a stake credential
/// registration certificate in the case of so-called pointer addresses.
pub type Referenced<a> {
  Inline(a)
  Pointer { slot_number: Int, transaction_index: Int, certificate_index: Int }
}

/// A `StakeCredential` represents the delegation and rewards withdrawal conditions
/// associated with some stake address / account.
///
/// A `StakeCredential` is either provided inline, or, by reference using an
/// on-chain pointer.
///
/// Read more about pointers in [CIP-0019 :: Pointers](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#pointers).
pub type StakeCredential =
  Referenced<Credential>

/// A 'PaymentCredential' represents the spending conditions associated with
/// some output. Hence,
///
/// - a `VerificationKey` captures an output locked by a public/private key pair;
/// - and a `Script` captures an output locked by a native or Plutus script.
///
pub type PaymentCredential =
  Credential



================================================
FILE: lib/cardano/assets.ak
================================================
use aiken/builtin
use aiken/collection/dict.{Dict, from_ascending_pairs_with}
use aiken/collection/dict/strategy as dict_strategy
use aiken/collection/list
use aiken/crypto.{Blake2b_224, Hash, Script}
use cardano/assets/strategy.{FlattenStrategy}

/// Lovelace is now a type wrapper for Int.
pub type Lovelace =
  Int

/// A type-alias for a `PolicyId`. A `PolicyId` is always 28-byte long
pub type PolicyId =
  Hash<Blake2b_224, Script>

/// Ada, the native currency, isn't associated with any `PolicyId` (it's not
/// possible to mint Ada!).
///
/// By convention, it is an empty `ByteArray`.
pub const ada_policy_id = ""

/// A type-alias for 'AssetName`, which are free-form byte-arrays between
/// 0 and 32 bytes.
pub type AssetName =
  ByteArray

/// Ada, the native currency, isn't associated with any `AssetName` (it's not
/// possible to mint Ada!).
///
/// By convention, it is an empty `ByteArray`.
pub const ada_asset_name = ""

/// A multi-asset output `Value`. Contains tokens indexed by [PolicyId](#PolicyId) and [AssetName](#AssetName).
///
/// > [!IMPORTANT]
/// > This type maintain some invariants by construction; in particular, a `Value` will never contain a
/// zero quantity of a particular token.
pub opaque type Value {
  inner: Dict<PolicyId, Dict<AssetName, Int>>,
}

// ## Constructing

/// Construct a `Value` from an asset identifier (i.e. `PolicyId` + `AssetName`)
/// and a given quantity.
pub fn from_asset(
  policy_id: PolicyId,
  asset_name: AssetName,
  quantity: Int,
) -> Value {
  if quantity == 0 {
    zero
  } else {
    let asset =
      dict.empty
        |> dict.insert(asset_name, quantity)
    dict.empty
      |> dict.insert(policy_id, asset)
      |> Value
  }
}

/// Promote an arbitrary list of assets into a `Value`. This function fails
/// (i.e. halts the program execution) if:
///
/// - there's any duplicate amongst `PolicyId`;
/// - there's any duplicate amongst `AssetName`;
/// - the `AssetName` aren't sorted in ascending lexicographic order; or
/// - any asset quantity is null.
///
/// This function is meant to turn arbitrary user-defined `Data` into safe `Value`,
/// while checking for internal invariants.
pub fn from_asset_list(xs: Pairs<PolicyId, Pairs<AssetName, Int>>) -> Value {
  xs
    |> list.foldr(
        dict.empty,
        fn(inner, acc) {
          expect Pair(p, [_, ..] as x) = inner
          x
            |> from_ascending_pairs_with(fn(v) { v != 0 })
            |> dict.insert_with(acc, p, _, dict_strategy.expect_no_duplicate())
        },
      )
    |> Value
}

test from_asset_list_1() {
  let v = from_asset_list([])
  v == zero
}

test from_asset_list_2() fail {
  let v = from_asset_list([Pair(#"33", [])])
  v == zero
}

test from_asset_list_3() fail {
  let v = from_asset_list([Pair(#"33", [Pair(#"", 0)])])
  v != zero
}

test from_asset_list_4() {
  let v = from_asset_list([Pair(#"33", [Pair(#"", 1)])])
  flatten(v) == [(#"33", #"", 1)]
}

test from_asset_list_5() {
  let v = from_asset_list([Pair(#"33", [Pair(#"", 1), Pair(#"33", 1)])])
  flatten(v) == [(#"33", #"", 1), (#"33", #"33", 1)]
}

test from_asset_list_6() fail {
  let v =
    from_asset_list(
      [
        Pair(#"33", [Pair(#"", 1), Pair(#"33", 1)]),
        Pair(#"33", [Pair(#"", 1), Pair(#"33", 1)]),
      ],
    )
  v != zero
}

test from_asset_list_7() fail {
  let v =
    from_asset_list(
      [
        Pair(#"33", [Pair(#"", 1), Pair(#"33", 1)]),
        Pair(#"34", [Pair(#"", 1), Pair(#"", 1)]),
      ],
    )
  v != zero
}

test from_asset_list_8() {
  let v =
    from_asset_list(
      [
        Pair(#"33", [Pair(#"", 1), Pair(#"33", 1)]),
        Pair(#"34", [Pair(#"31", 1)]), Pair(#"35", [Pair(#"", 1)]),
      ],
    )
  flatten(v) == [
    (#"33", #"", 1), (#"33", #"33", 1), (#"34", #"31", 1), (#"35", #"", 1),
  ]
}

test from_asset_list_9() {
  let v =
    from_asset_list(
      [
        Pair(#"35", [Pair(#"", 1)]), Pair(#"33", [Pair(#"", 1), Pair(#"33", 1)]),
        Pair(#"34", [Pair(#"31", 1)]),
      ],
    )
  flatten(v) == [
    (#"33", #"", 1), (#"33", #"33", 1), (#"34", #"31", 1), (#"35", #"", 1),
  ]
}

/// Construct a `Value` from a lovelace quantity.
///
/// Friendly reminder: 1 Ada = 1.000.000 Lovelace
pub fn from_lovelace(quantity: Int) -> Value {
  from_asset(ada_policy_id, ada_asset_name, quantity)
}

/// Construct an empty `Value` with nothing in it.
pub const zero: Value = Value { inner: dict.empty }

// ## Inspecting

/// Check whether a `Value` carries any NFT from the given policy. Other assets are tolerated.
///
/// ```aiken
/// let value = assets.from_lovelace(42)
///    |> assets.add("foo", "asset#1", 1)
///    |> assets.add("bar", "asset#2", 14)
///
/// assets.has_any_nft(value, "foo") == True
/// assets.has_any_nft(value, "bar") == False
/// assets.has_any_nft(value, "baz") == False
/// ```
pub fn has_any_nft(self: Value, policy: PolicyId) -> Bool {
  tokens(self, policy)
    |> dict.foldr(False, fn(_, quantity, result) { result || quantity == 1 })
}

/// Check whether a `Value` carries any NFT from the given policy. Other assets (other than
/// Ada) aren't tolerated. Said differently, the check succeeds if and only if
/// the value contains no assets other than the expected NFT or Ada.
///
/// ```aiken
/// let value = assets.from_lovelace(42)
///    |> assets.add("foo", "asset#1", 1)
///    |> assets.add("bar", "asset#2", 14)
///
/// assets.has_any_nft_strict(value, "foo") == False
/// assets.has_any_nft_strict(value, "bar") == False
/// assets.has_any_nft_strict(value, "baz") == False
/// ```
///
/// ```aiken
/// let value = assets.from_lovelace(42)
///    |> assets.add("foo", "asset#1", 1)
///
/// assets.has_any_nft_strict(value, "foo") == True
/// assets.has_any_nft_strict(value, "bar") == False
/// ```
///
/// ```aiken
/// let value = assets.from_lovelace(42)
///    |> assets.add("foo", "asset#1", 1)
///    |> assets.add("foo", "asset#2", 1)
///
/// assets.has_any_nft_strict(value, "foo") == False
/// assets.has_any_nft_strict(value, "bar") == False
/// ```
pub fn has_any_nft_strict(self: Value, policy: PolicyId) -> Bool {
  let check_inner =
    fn(p, inner) {
      and {
        p == policy,
        when inner |> dict.to_pairs is {
          [Pair(_, 1)] -> True
          _ -> False
        },
      }
    }

  when self.inner |> dict.to_pairs is {
    [Pair(p1, _), Pair(p2, inner)] -> and {
        p1 == ada_policy_id,
        check_inner(p2, inner),
      }

    [Pair(p, inner)] -> check_inner(p, inner)

    _ -> False
  }
}

/// Check whether a `Value` carries a specific NFT. Other assets are tolerated.
///
/// ```aiken
/// let value = assets.from_lovelace(42)
///    |> assets.add("foo", "asset#1", 1)
///    |> assets.add("bar", "asset#2", 14)
///
/// assets.has_nft(value, "foo", "asset#1") == True
/// assets.has_nft(value, "foo", "asset#2") == False
/// assets.has_nft(value, "bar", "asset#2") == False
/// assets.has_nft(value, "baz", "asset#3") == False
/// ```
///
/// ```aiken
/// let value = assets.from_lovelace(42)
///    |> assets.add("foo", "asset#1", 1)
///    |> assets.add("foo", "asset#2", 1)
///
/// assets.has_nft(value, "foo", "asset#1") == True
/// assets.has_nft(value, "foo", "asset#2") == True
/// assets.has_nft(value, "bar", "asset#2") == False
/// ```
pub fn has_nft(self: Value, policy: PolicyId, asset_name: AssetName) -> Bool {
  quantity_of(self, policy, asset_name) == 1
}

/// Check whether a `Value` carries a specific NFT. Other assets (other than
/// Ada) aren't tolerated. Said differently, the check succeeds if and only if
/// the value contains no assets other than the expected NFT or Ada.
///
/// ```aiken
/// let value = assets.from_lovelace(42)
///    |> assets.add("foo", "asset#1", 1)
///    |> assets.add("bar", "asset#2", 14)
///
/// assets.has_nft_strict(value1, "foo", "asset#1") == False
/// assets.has_nft_strict(value1, "bar", "asset#2") == False
/// assets.has_nft_strict(value1, "baz", "asset#3") == False
/// ```
///
/// ```aiken
/// let value = assets.from_lovelace(42)
///    |> assets.add("foo", "asset#1", 1)
///
/// assets.has_nft_strict(value, "foo", "asset#1") == True
/// assets.has_nft_strict(value, "foo", "asset#2") == False
/// assets.has_nft_strict(value, "bar", "asset#2") == False
/// ```
///
/// ```aiken
/// let value = assets.from_lovelace(42)
///    |> assets.add("foo", "asset#1", 1)
///    |> assets.add("foo", "asset#2", 1)
///
/// assets.has_nft_strict(value3, "foo", "asset#1") == False
/// assets.has_nft_strict(value3, "foo", "asset#2") == False
/// ```
pub fn has_nft_strict(
  self: Value,
  policy: PolicyId,
  asset_name: AssetName,
) -> Bool {
  match(
    self,
    builtin.map_data(
      [
        builtin.new_pair(
          policy,
          builtin.map_data([builtin.new_pair(asset_name, 1)]),
        ),
      ],
    ),
    fn(_, _) { True },
  )
}

const has_nft_fixture_1: Value =
  from_lovelace(42)
    |> add("foo", "asset#1", 1)
    |> add("bar", "asset#2", 14)

const has_nft_fixture_2: Value =
  from_lovelace(42)
    |> add("foo", "asset#1", 1)

const has_nft_fixture_3: Value =
  from_lovelace(42)
    |> add("foo", "asset#1", 1)
    |> add("foo", "asset#2", 1)
    |> add("bar", "asset#2", 14)

test has_nft_with_fixture_1() {
  and {
    // has_any_nft
    has_any_nft(has_nft_fixture_1, "foo")?,
    (!has_any_nft(has_nft_fixture_1, "bar"))?,
    (!has_any_nft(has_nft_fixture_1, "baz"))?,
    // has_any_nft_strict
    (!has_any_nft_strict(has_nft_fixture_1, "foo"))?,
    (!has_any_nft_strict(has_nft_fixture_1, "bar"))?,
    (!has_any_nft_strict(has_nft_fixture_1, "baz"))?,
    // has_nft
    has_nft(has_nft_fixture_1, "foo", "asset#1")?,
    (!has_nft(has_nft_fixture_1, "foo", "asset#2"))?,
    (!has_nft(has_nft_fixture_1, "bar", "asset#2"))?,
    (!has_nft(has_nft_fixture_1, "baz", "asset#1"))?,
    // has_nft_strict
    (!has_nft_strict(has_nft_fixture_1, "foo", "asset#1"))?,
    (!has_nft_strict(has_nft_fixture_1, "foo", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_1, "bar", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_1, "baz", "asset#1"))?,
  }
}

test has_nft_with_fixture_1_without_lovelace() {
  let has_nft_fixture_1 = without_lovelace(has_nft_fixture_1)
  and {
    // has_any_nft
    has_any_nft(has_nft_fixture_1, "foo")?,
    (!has_any_nft(has_nft_fixture_1, "bar"))?,
    (!has_any_nft(has_nft_fixture_1, "baz"))?,
    // has_any_nft_strict
    (!has_any_nft_strict(has_nft_fixture_1, "foo"))?,
    (!has_any_nft_strict(has_nft_fixture_1, "bar"))?,
    (!has_any_nft_strict(has_nft_fixture_1, "baz"))?,
    // has_nft
    has_nft(has_nft_fixture_1, "foo", "asset#1")?,
    (!has_nft(has_nft_fixture_1, "foo", "asset#2"))?,
    (!has_nft(has_nft_fixture_1, "bar", "asset#2"))?,
    (!has_nft(has_nft_fixture_1, "baz", "asset#1"))?,
    // has_nft_strict
    (!has_nft_strict(has_nft_fixture_1, "foo", "asset#1"))?,
    (!has_nft_strict(has_nft_fixture_1, "foo", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_1, "bar", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_1, "baz", "asset#1"))?,
  }
}

test has_nft_with_fixture_2() {
  and {
    // has_any_nft
    has_any_nft(has_nft_fixture_2, "foo")?,
    (!has_any_nft(has_nft_fixture_2, "bar"))?,
    (!has_any_nft(has_nft_fixture_2, "baz"))?,
    // has_any_nft_strict
    has_any_nft_strict(has_nft_fixture_2, "foo")?,
    (!has_any_nft_strict(has_nft_fixture_2, "bar"))?,
    (!has_any_nft_strict(has_nft_fixture_2, "baz"))?,
    // has_nft
    has_nft(has_nft_fixture_2, "foo", "asset#1")?,
    (!has_nft(has_nft_fixture_2, "foo", "asset#2"))?,
    (!has_nft(has_nft_fixture_2, "bar", "asset#2"))?,
    (!has_nft(has_nft_fixture_2, "baz", "asset#1"))?,
    // has_nft_strict
    has_nft_strict(has_nft_fixture_2, "foo", "asset#1")?,
    (!has_nft_strict(has_nft_fixture_2, "foo", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_2, "bar", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_2, "baz", "asset#1"))?,
  }
}

test has_nft_with_fixture_2_without_lovelace() {
  let has_nft_fixture_2 = without_lovelace(has_nft_fixture_2)
  and {
    // has_any_nft
    has_any_nft(has_nft_fixture_2, "foo")?,
    (!has_any_nft(has_nft_fixture_2, "bar"))?,
    (!has_any_nft(has_nft_fixture_2, "baz"))?,
    // has_any_nft_strict
    has_any_nft_strict(has_nft_fixture_2, "foo")?,
    (!has_any_nft_strict(has_nft_fixture_2, "bar"))?,
    (!has_any_nft_strict(has_nft_fixture_2, "baz"))?,
    // has_nft
    has_nft(has_nft_fixture_2, "foo", "asset#1")?,
    (!has_nft(has_nft_fixture_2, "foo", "asset#2"))?,
    (!has_nft(has_nft_fixture_2, "bar", "asset#2"))?,
    (!has_nft(has_nft_fixture_2, "baz", "asset#1"))?,
    // has_nft_strict
    has_nft_strict(has_nft_fixture_2, "foo", "asset#1")?,
    (!has_nft_strict(has_nft_fixture_2, "foo", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_2, "bar", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_2, "baz", "asset#1"))?,
  }
}

test has_nft_with_fixture_3() {
  and {
    // has_any_nft
    has_any_nft(has_nft_fixture_3, "foo")?,
    (!has_any_nft(has_nft_fixture_3, "bar"))?,
    (!has_any_nft(has_nft_fixture_3, "baz"))?,
    // has_any_nft_strict
    (!has_any_nft_strict(has_nft_fixture_3, "foo"))?,
    (!has_any_nft_strict(has_nft_fixture_3, "bar"))?,
    (!has_any_nft_strict(has_nft_fixture_3, "baz"))?,
    // has_nft
    has_nft(has_nft_fixture_3, "foo", "asset#1")?,
    has_nft(has_nft_fixture_3, "foo", "asset#2")?,
    (!has_nft(has_nft_fixture_3, "bar", "asset#2"))?,
    (!has_nft(has_nft_fixture_3, "baz", "asset#1"))?,
    // has_nft_strict
    (!has_nft_strict(has_nft_fixture_3, "foo", "asset#1"))?,
    (!has_nft_strict(has_nft_fixture_3, "foo", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_3, "bar", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_3, "baz", "asset#1"))?,
  }
}

test has_nft_with_fixture_3_without_lovelace() {
  let has_nft_fixture_3 = without_lovelace(has_nft_fixture_3)
  and {
    // has_any_nft
    has_any_nft(has_nft_fixture_3, "foo")?,
    (!has_any_nft(has_nft_fixture_3, "bar"))?,
    (!has_any_nft(has_nft_fixture_3, "baz"))?,
    // has_any_nft_strict
    (!has_any_nft_strict(has_nft_fixture_3, "foo"))?,
    (!has_any_nft_strict(has_nft_fixture_3, "bar"))?,
    (!has_any_nft_strict(has_nft_fixture_3, "baz"))?,
    // has_nft
    has_nft(has_nft_fixture_3, "foo", "asset#1")?,
    has_nft(has_nft_fixture_3, "foo", "asset#2")?,
    (!has_nft(has_nft_fixture_3, "bar", "asset#2"))?,
    (!has_nft(has_nft_fixture_3, "baz", "asset#1"))?,
    // has_nft_strict
    (!has_nft_strict(has_nft_fixture_3, "foo", "asset#1"))?,
    (!has_nft_strict(has_nft_fixture_3, "foo", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_3, "bar", "asset#2"))?,
    (!has_nft_strict(has_nft_fixture_3, "baz", "asset#1"))?,
  }
}

/// Check is a `Value` is zero. That is, it has no assets and holds no Ada/Lovelace.
pub fn is_zero(self: Value) -> Bool {
  self == zero
}

/// Efficiently compare two values together, allowing a custom behaviour for Ada/Lovelace.
/// The second parameter is provided as `Data`, allowing to conveniently compare serialized
/// datums or similar structurually equivalent types (such as `Pairs<PolicyId, Pairs<AssetName, Lovelace>>`).
///
/// The third argument is a callback function to assert the left and right lovelace
/// quantities. Its first argument refers to the quantity of the first argument of
/// `match`, and the second argument of the callback to the quantity of the second
/// argument of `match`. In the absence of lovelace in any value, it defaults to `0`.
///
/// ```aiken
/// const value: Value =
///   assets.from_lovelace(30)
///     |> assets.add("foo", "bar", 1)
///     |> assets.add("foo", "baz", 42)
///
/// const datum: Data =
///   assets.from_lovelace(20)
///     |> assets.add("foo", "bar", 1)
///     |> assets.add("foo", "baz", 42)
///
/// True == assets.match(value, datum, >=)
///
/// False == assets.match(value, datum, ==)
///
/// True == assets.match(value, datum, fn(value_lovelace, datum_lovelace) {
///   2 * datum_lovelace >= value_lovelace
/// })
/// ```
pub fn match(
  left: Value,
  right: Data,
  assert_lovelace: fn(Lovelace, Lovelace) -> Bool,
) -> Bool {
  builtin.choose_data(
    right,
    False,
    {
      let (left_lovelace, left_assets) = dict.pop(left.inner, ada_policy_id)
      let left_assets: Data = left_assets
      let left_lovelace =
        when left_lovelace is {
          Some(tokens) -> builtin.head_list(dict.to_pairs(tokens)).2nd
          None -> 0
        }
      when builtin.un_map_data(right) is {
        [] -> left_assets == right && assert_lovelace(left_lovelace, 0)
        [first_asset, ..right_assets] ->
          if first_asset.1st == builtin.b_data(ada_policy_id) {
            and {
              assert_lovelace(
                left_lovelace,
                builtin.un_i_data(
                  builtin.head_list(builtin.un_map_data(first_asset.2nd)).2nd,
                ),
              ),
              left_assets == builtin.map_data(right_assets),
            }
          } else {
            and {
              assert_lovelace(left_lovelace, 0),
              left_assets == right,
            }
          }
      }
    },
    False,
    False,
    False,
  )
}

const fixture_match_value: Value =
  zero
    |> add(ada_policy_id, ada_asset_name, 42)
    |> add("foo", "01", 1)
    |> add("foo", "02", 1)
    |> add("bar", "01", 42)

const fixture_match_data: Data =
  zero
    |> add(ada_policy_id, ada_asset_name, 14)
    |> add("foo", "01", 1)
    |> add("foo", "02", 1)
    |> add("bar", "01", 42)

const fixture_match_data_missing_foo_02: Data =
  zero
    |> add(ada_policy_id, ada_asset_name, 14)
    |> add("foo", "01", 1)
    |> add("bar", "01", 42)

const fixture_match_data_altered_foo_01: Data =
  zero
    |> add(ada_policy_id, ada_asset_name, 14)
    |> add("foo", "01", 14)
    |> add("foo", "02", 1)
    |> add("bar", "01", 42)

const fixture_match_data_missing_bar: Data =
  zero
    |> add(ada_policy_id, ada_asset_name, 14)
    |> add("foo", "01", 1)
    |> add("foo", "02", 1)

const fixture_match_data_extra_policy: Data =
  zero
    |> add(ada_policy_id, ada_asset_name, 14)
    |> add("foo", "01", 1)
    |> add("foo", "02", 1)
    |> add("bar", "01", 42)
    |> add("baz", "01", 1)

const fixture_match_data_extra_asset: Data =
  zero
    |> add(ada_policy_id, ada_asset_name, 14)
    |> add("foo", "01", 1)
    |> add("foo", "02", 1)
    |> add("foo", "03", 1)
    |> add("bar", "01", 42)

const fixture_match_data_no_assets: Data =
  zero
    |> add(ada_policy_id, ada_asset_name, 14)

test match_1() {
  match(fixture_match_value, fixture_match_data, fn(_, _) { True })
}

test match_2() {
  !match(
    fixture_match_value,
    fixture_match_data,
    fn(source, target) { source == target },
  )
}

test match_3() {
  !match(
    fixture_match_value,
    fixture_match_data_missing_foo_02,
    fn(_, _) { True },
  )
}

test match_4() {
  !match(fixture_match_value, fixture_match_data_missing_bar, fn(_, _) { True })
}

test match_5() {
  !match(
    fixture_match_value,
    fixture_match_data_altered_foo_01,
    fn(_, _) { True },
  )
}

test match_6() {
  !match(
    fixture_match_value,
    fixture_match_data_extra_policy,
    fn(_, _) { True },
  )
}

test match_7() {
  !match(fixture_match_value, fixture_match_data_extra_asset, fn(_, _) { True })
}

test match_8() {
  !match(fixture_match_value, fixture_match_data_no_assets, fn(_, _) { True })
}

test match_9() {
  match(zero, zero, ==)
}

test match_10() {
  match(
    without_lovelace(fixture_match_value),
    without_lovelace(fixture_match_value),
    fn(left, right) { left == 0 && right == 0 },
  )
}

test match_11() {
  match(
    without_lovelace(fixture_match_value),
    fixture_match_value,
    fn(left, right) { left == 0 && right > 0 },
  )
}

test match_12() {
  match(
    fixture_match_value,
    without_lovelace(fixture_match_value),
    fn(left, right) { left > 0 && right == 0 },
  )
}

test match_13() {
  match(
    zero |> add(ada_policy_id, ada_asset_name, 42),
    zero,
    fn(left, right) { left == 42 && right == 0 },
  )
}

test match_14() {
  match(
    zero,
    zero |> add(ada_policy_id, ada_asset_name, 42),
    fn(left, right) { left == 0 && right == 42 },
  )
}

const fixture_match_benchmark_left: Value =
  zero
    |> add(ada_policy_id, ada_asset_name, 1337)
    |> add(
        #"0246a14d04c3a0e9b65f6b90a3d1aa5faee5d56ab1e30ec7e8b02f29",
        "MATTR",
        200,
      )
    |> add(
        #"0a9e126256cb38c4865cdac6eb2ada51c328ba0df2ebde22ae126c0d",
        "ProphecyPoster076",
        1,
      )
    |> add(
        #"1774343241680e4daef7cbfe3536fc857ce23fb66cd0b66320b2e3dd",
        "BISON",
        12_004_999_999,
      )
    |> add(
        #"279c909f348e533da5808898f87f9a14bb2c3dfbbacccd631d927a3f",
        "SNEK",
        1486,
      )
    |> add(
        #"651dfc074202423585996ffa717cb45237d307e705e2cc3dab1ccabd",
        "MAYZSilverFoundersEdition0035",
        1,
      )
    |> add(
        #"63df49056617dd14034986cf7c250bad6552fd2f0f9c71d797932008",
        "CardanoSpaceSession",
        20,
      )
    |> add(
        #"5b01968867e13432afaa2f814e1d15e332d6cd0aa77e350972b0967d",
        "ADAOGovernanceToken",
        1,
      )
    |> add(
        #"a0028f350aaabe0545fdcb56b039bfb08e4bb4d8c4d7c3c7d481c235",
        "HOSKY",
        400_001_000,
      )
    |> add(
        #"da8c30857834c6ae7203935b89278c532b3995245295456f993e1d24",
        "LQ",
        10_635_899,
      )
    |> add(
        #"95d9a98c2f7999a3d5e0f4d795cb1333837c09eb0f24835cd2ce954c",
        "GrandmasterAdventurer659",
        1,
      )
    |> add(
        #"702cbdb06a81ef2fa4f85f9e32159c03f502539d762a71194fc11eb3",
        "AdventurerOfThiolden8105",
        1,
      )
    |> add(
        #"d0112837f8f856b2ca14f69b375bc394e73d146fdadcc993bb993779",
        "DiscoSolaris3725",
        1,
      )
    |> add(
        #"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a",
        "CardaWorld535",
        1,
      )
    |> add(
        #"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a",
        "CardaWorld1213",
        1,
      )
    |> add(
        #"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a",
        "CardaWorld1518",
        1,
      )
    |> add(
        #"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a",
        "CardaWorld1537",
        1,
      )
    |> add(
        #"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a",
        "CardaWorld4199",
        1,
      )
    |> add(
        #"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a",
        "CardaWorld3767",
        1,
      )
    |> add(
        #"7597444754551a8c17edbf7291cdaeca898ca02ee4e732b09a949396",
        "Algae1",
        1,
      )
    |> add(
        #"7597444754551a8c17edbf7291cdaeca898ca02ee4e732b09a949396",
        "Algae2",
        1,
      )

const fixture_match_benchmark_right: Data = fixture_match_benchmark_left

test match_benchmark() {
  match(fixture_match_benchmark_left, fixture_match_benchmark_right, ==)
}

test match_benchmark_vs() {
  let data: Data = fixture_match_benchmark_right
  expect pairs: Pairs<PolicyId, Pairs<AssetName, Int>> = data
  fixture_match_benchmark_left == from_asset_list(pairs)
}

/// A specialized version of `quantity_of` for the Ada currency.
pub fn lovelace_of(self: Value) -> Int {
  quantity_of(self, ada_policy_id, ada_asset_name)
}

/// A list of all token policies in that Value with non-zero tokens.
pub fn policies(self: Value) -> List<PolicyId> {
  dict.keys(self.inner)
}

/// Extract the quantity of a given asset.
pub fn quantity_of(
  self: Value,
  policy_id: PolicyId,
  asset_name: AssetName,
) -> Int {
  tokens(self, policy_id)
    |> dict.get_or_else(asset_name, fn() { 0 })
}

/// Get all tokens associated with a given policy.
pub fn tokens(self: Value, policy_id: PolicyId) -> Dict<AssetName, Int> {
  self.inner
    |> dict.get_or_else(policy_id, fn() { dict.empty })
}

// ## Combining

/// Add a (positive or negative) quantity of a single token to a assets.
/// This is more efficient than [`merge`](#merge) for a single asset.
pub fn add(
  self: Value,
  policy_id: PolicyId,
  asset_name: AssetName,
  quantity: Int,
) -> Value {
  if quantity == 0 {
    self
  } else {
    let helper =
      fn(_, left, _right, keep, discard) {
        let inner_result =
          dict.insert_with(
            left,
            asset_name,
            quantity,
            dict_strategy.sum_if_non_zero(),
          )

        if dict.is_empty(inner_result) {
          discard()
        } else {
          keep(inner_result)
        }
      }

    Value(
      dict.insert_with(
        self.inner,
        policy_id,
        dict.from_ascending_pairs([Pair(asset_name, quantity)]),
        helper,
      ),
    )
  }
}

test add_1() {
  let v =
    zero
      |> add(#"acab", #"beef", 321)
      |> add(#"acab", #"beef", -321)
  v == zero
}

test add_2() {
  let v =
    from_lovelace(123)
      |> add(#"acab", #"beef", 321)
      |> add(#"acab", #"beef", -1 * 321)
  v == from_lovelace(123)
}

test add_3() {
  let v =
    from_lovelace(1)
      |> add(ada_policy_id, ada_asset_name, 2)
      |> add(ada_policy_id, ada_asset_name, 3)
  v == from_lovelace(6)
}

test add_4() {
  let v =
    zero
      |> add(#"acab", #"beef", 0)
  v == zero
}

test add_5() {
  let v =
    zero
      |> add(#"acab", #"beef", 0)
      |> add(#"acab", #"beef", 0)
  v == zero
}

/// Combine two `Value` together.
pub fn merge(left v0: Value, right v1: Value) -> Value {
  Value(
    dict.union_with(
      v0.inner,
      v1.inner,
      fn(_, a0, a1, keep, discard) {
        let result = dict.union_with(a0, a1, dict_strategy.sum_if_non_zero())
        if dict.is_empty(result) {
          discard()
        } else {
          keep(result)
        }
      },
    ),
  )
}

test merge_1() {
  let v1 = from_lovelace(1)
  let v2 = from_lovelace(-1)
  merge(v1, v2) == zero
}

test merge_2() {
  let v1 = from_asset(#"00", #"", 1)
  let v2 = from_asset(#"01", #"", 2)
  let v3 = from_asset(#"02", #"", 3)
  let v =
    from_lovelace(42)
      |> merge(v3)
      |> merge(v1)
      |> merge(v2)

  flatten(v) == [
    (#"", #"", 42), (#"00", #"", 1), (#"01", #"", 2), (#"02", #"", 3),
  ]
}

test merge_3() {
  let v1 = from_asset(#"00", #"", 1)
  let v2 = from_asset(#"00", #"", -1)
  let v3 = from_asset(#"01", #"", 1)

  let v =
    zero
      |> merge(v1)
      |> merge(v2)
      |> merge(v3)

  flatten(v) == [(#"01", #"", 1)]
}

test merge_4() {
  let v1 = from_asset(#"00", #"", 1)
  let v2 = from_asset(#"00", #"", -1)

  merge(v1, v2) == zero
}

test merge_5() {
  let v =
    zero
      |> add(#"acab", #"beef", 0)

  merge(zero, v) == zero
}

/// Negates quantities of all tokens (including Ada) in that `Value`.
///
/// ```
/// v1
///   |> assets.negate
///   |> assets.merge(v1)
///   |> assets.is_zero
/// // True
/// ```
pub fn negate(self: Value) -> Value {
  dict.map(self.inner, fn(_, a) { dict.map(a, fn(_, q) { 0 - q }) })
    |> Value
}

/// Get a subset of the assets restricted to the given policies.
pub fn restricted_to(self: Value, mask: List<PolicyId>) -> Value {
  list.foldr(
    policies(self),
    zero,
    fn(policy_id, value) {
      if list.has(mask, policy_id) {
        dict.foldr(
          tokens(self, policy_id),
          value,
          fn(asset_name, quantity, value) {
            add(value, policy_id, asset_name, quantity)
          },
        )
      } else {
        value
      }
    },
  )
}

test restricted_to_1() {
  let self = from_lovelace(42) |> add("foo", "", 1)
  restricted_to(self, []) == zero
}

test restricted_to_2() {
  let self = from_lovelace(42) |> add("foo", "", 1)
  restricted_to(self, [ada_policy_id]) == from_lovelace(42)
}

test restricted_to_3() {
  let self = from_lovelace(42) |> add("foo", "", 1) |> add("bar", "", 1)
  restricted_to(self, ["foo", "bar"]) == without_lovelace(self)
}

test restricted_to_4() {
  let self = from_lovelace(42) |> add("foo", "bar", 1) |> add("foo", "baz", 1)
  restricted_to(self, ["foo"]) == without_lovelace(self)
}

test restricted_to_5() {
  let self = from_lovelace(42) |> add("foo", "bar", 1) |> add("foo", "baz", 1)
  restricted_to(self, [ada_policy_id, "foo"]) == self
}

/// Get a `Value` excluding Ada.
pub fn without_lovelace(self: Value) -> Value {
  dict.delete(self.inner, ada_policy_id)
    |> Value
}

test without_lovelace_1() {
  let v = from_lovelace(1000000)
  without_lovelace(v) == zero
}

test without_lovelace_2() {
  let v = from_lovelace(1000000)
  let v2 = from_lovelace(50000000)
  without_lovelace(v) == without_lovelace(v2)
}

test without_lovelace_3() {
  let v =
    from_asset(#"010203", #"040506", 100)
      |> add(ada_policy_id, ada_asset_name, 100000000)
  let v2 = from_asset(#"010203", #"040506", 100)
  without_lovelace(v) == without_lovelace(v2) && without_lovelace(v) == v2
}

// ## Transforming

/// Flatten a `Value` as list of 3-tuple `(PolicyId, AssetName, Quantity)`.
///
/// Handy to manipulate values as uniform lists.
pub fn flatten(self: Value) -> List<(PolicyId, AssetName, Int)> {
  dict.foldr(
    self.inner,
    [],
    fn(policy_id, asset_list, value) {
      dict.foldr(
        asset_list,
        value,
        fn(asset_name, quantity, xs) {
          [(policy_id, asset_name, quantity), ..xs]
        },
      )
    },
  )
}

/// Flatten a `Value` as a list of results, possibly discarding some along the way. In particular, we have:
///
/// ```aiken
/// flatten(value) === flatten_with(value, strategy.triple())
/// ```
pub fn flatten_with(self: Value, with: FlattenStrategy<result>) -> List<result> {
  dict.foldr(
    self.inner,
    [],
    fn(policy_id, asset_list, value) {
      dict.foldr(
        asset_list,
        value,
        fn(asset_name, quantity, xs) {
          with(
            policy_id,
            asset_name,
            quantity,
            fn(x) { [x, ..xs] },
            fn() { xs },
          )
        },
      )
    },
  )
}

test flatten_with_1() {
  flatten_with(zero, strategy.triple()) == []
}

test flatten_with_2() {
  let v =
    zero
      |> add("a", "1", 14)
      |> add("b", "", 42)
      |> add("a", "2", 42)

  flatten_with(
    v,
    fn(p, a, q, keep, discard) {
      if q == 42 {
        keep((p, a))
      } else {
        discard()
      }
    },
  ) == [("a", "2"), ("b", "")]
}

/// Reduce a value into a single result
///
/// ```
/// assets.zero
///  |> assets.add("a", "1", 10)
///  |> assets.add("b", "2", 20)
///  |> assets.reduce(v, 0, fn(_, _, quantity, acc) { acc + quantity })
/// // 30
/// ```
pub fn reduce(
  self: Value,
  start: result,
  with: fn(PolicyId, AssetName, Int, result) -> result,
) -> result {
  dict.foldr(
    self.inner,
    start,
    fn(policy_id, asset_list, result) {
      dict.foldr(asset_list, result, with(policy_id, _, _, _))
    },
  )
}

test reduce_1() {
  let v =
    zero
      |> add("a", "1", 10)
      |> add("b", "2", 20)
  let result = reduce(v, 0, fn(_, _, quantity, acc) { acc + quantity })
  result == 30
}

test reduce_2() {
  let v =
    zero
      |> add("a", "1", 5)
      |> add("a", "2", 15)
      |> add("b", "", 10)
  let result =
    reduce(
      v,
      [],
      fn(policy_id, asset_name, _, acc) { [(policy_id, asset_name), ..acc] },
    )
  result == [("a", "1"), ("a", "2"), ("b", "")]
}

test reduce_3() {
  let v = zero
  let result = reduce(v, 1, fn(_, _, quantity, acc) { acc + quantity })
  result == 1
}

/// Convert the value into a dictionary of dictionaries.
pub fn to_dict(self: Value) -> Dict<PolicyId, Dict<AssetName, Int>> {
  self.inner
}



================================================
FILE: lib/cardano/certificate.ak
================================================
use aiken/crypto.{Blake2b_224, Hash, VerificationKey, VerificationKeyHash}
use cardano/address.{Credential}
use cardano/assets.{Lovelace}

pub type StakePoolId =
  Hash<Blake2b_224, VerificationKey>

/// An on-chain certificate attesting of some operation. Publishing
/// certificates triggers different kind of rules; most of the time,
/// they require signatures from specific keys.
pub type Certificate {
  /// Register a stake credential with an optional deposit amount.
  /// The deposit is always present when using the new registration certificate
  /// format available since the Conway era.
  RegisterCredential {
    credential: Credential,
    /// > [!NOTE]
    /// > The `deposit` ought to be an `Option<Lovelace>`, but due to unfortunate
    /// > circumstances it will always be instantiated to `None` even when set in
    /// > the host transaction. This is what the `Never` type captures here.
    deposit: Never,
  }
  /// Un-Register a stake credential with an optional refund amount
  /// The deposit is always present when using the new de-registration certificate
  /// format available since the Conway era.
  UnregisterCredential {
    credential: Credential,
    /// > [!NOTE]
    /// > The `refund` ought to be an `Option<Lovelace>`, but due to unfortunate
    /// > circumstances it will always be instantiated to `None` even when set in
    /// > the host transaction. This is what the `Never` type captures here.
    refund: Never,
  }
  /// Delegate stake to a [Delegate](#Delegate).
  DelegateCredential { credential: Credential, delegate: Delegate }
  /// Register and delegate staking credential to a Delegatee in one certificate.
  RegisterAndDelegateCredential {
    credential: Credential,
    delegate: Delegate,
    deposit: Lovelace,
  }
  /// Register a delegate representative (a.k.a DRep). The deposit is explicit and
  /// is refunded when the delegate steps down (unregister).
  RegisterDelegateRepresentative {
    delegate_representative: Credential,
    deposit: Lovelace,
  }
  /// Update a delegate representative (a.k.a DRep). The certificate also contains
  /// metadata which aren't visible on-chain.
  UpdateDelegateRepresentative { delegate_representative: Credential }
  /// UnRegister a delegate representative, and refund back its past deposit.
  UnregisterDelegateRepresentative {
    delegate_representative: Credential,
    refund: Lovelace,
  }
  /// Register a new stake pool
  RegisterStakePool {
    /// The hash digest of the stake pool's cold (public) key
    stake_pool: StakePoolId,
    /// The hash digest of the stake pool's VRF (public) key
    vrf: VerificationKeyHash,
  }
  /// Retire a stake pool. 'at_epoch' indicates in which the retirement will take place
  RetireStakePool { stake_pool: StakePoolId, at_epoch: Int }
  /// Authorize a Hot credential for a specific Committee member's cold credential
  AuthorizeConstitutionalCommitteeProxy {
    constitutional_committee_member: Credential,
    proxy: Credential,
  }
  /// Step down from the constitutional committee as a member.
  RetireFromConstitutionalCommittee {
    constitutional_committee_member: Credential,
  }
}

/// A type of stake delegation that can be either block-production, vote or
/// both. Note that delegation types aren't cancelling one another, so it is
/// possible to delegate block production in one transaction, and delegate vote
/// in another. This second delegation **does NOT** invalidate the first one.
pub type Delegate {
  DelegateBlockProduction { stake_pool: StakePoolId }
  DelegateVote { delegate_representative: DelegateRepresentative }
  DelegateBoth {
    stake_pool: StakePoolId,
    delegate_representative: DelegateRepresentative,
  }
}

pub type DelegateRepresentative {
  Registered(Credential)
  AlwaysAbstain
  AlwaysNoConfidence
}



================================================
FILE: lib/cardano/governance.ak
================================================
use aiken/collection.{Index}
use aiken/crypto.{Blake2b_256, Hash, ScriptHash, VerificationKeyHash}
use aiken/math/rational.{Rational}
use cardano/address.{Credential}
use cardano/assets.{Lovelace}
use cardano/governance/protocol_parameters.{ProtocolParametersUpdate}

pub type ProposalProcedure {
  deposit: Lovelace,
  return_address: Credential,
  governance_action: GovernanceAction,
}

pub type GovernanceAction {
  ProtocolParameters {
    /// The last governance action of type 'ProtocolParameters'. They must all
    /// form a chain.
    ancestor: Option<GovernanceActionId>,
    /// The new proposed protocol parameters. Only values set to `Some` are relevant.
    new_parameters: ProtocolParametersUpdate,
    /// The optional guardrails script defined in the constitution. The script
    /// is executed by the ledger in addition to the hard-coded ledger rules.
    ///
    /// It must pass for the new protocol parameters to be deemed valid.
    guardrails: Option<ScriptHash>,
  }
  HardFork {
    /// The last governance action of type `HardFork`. They must all
    /// form a chain.
    ancestor: Option<GovernanceActionId>,
    /// The new proposed version. Few rules apply to proposing new versions:
    ///
    /// - The `major` component, if incremented, must be exactly one more than the current.
    /// - The `minor` component, if incremented, must be exactly one more than the current.
    /// - If the `major` component is incremented, `minor` must be set to `0`.
    /// - Neither `minor` nor `major` can be decremented.
    new_version: ProtocolVersion,
  }
  TreasuryWithdrawal {
    /// A collection of beneficiaries, which can be plain verification key
    /// hashes or script hashes (e.g. DAO).
    beneficiaries: Pairs<Credential, Lovelace>,
    /// The optional guardrails script defined in the constitution. The script
    /// is executed by the ledger in addition to the hard-coded ledger rules.
    ///
    /// It must pass for the withdrawals to be authorized.
    guardrails: Option<ScriptHash>,
  }
  NoConfidence {
    /// The last governance action of type `NoConfidence` or
    /// `ConstitutionalCommittee`. They must all / form a chain.
    ancestor: Option<GovernanceActionId>,
  }
  ConstitutionalCommittee {
    /// The last governance action of type `NoConfidence` or
    /// `ConstitutionalCommittee`. They must all / form a chain.
    ancestor: Option<GovernanceActionId>,
    /// Constitutional members to be removed.
    evicted_members: List<Credential>,
    /// Constitutional members to be added.
    added_members: Pairs<Credential, Mandate>,
    /// The new quorum value, as a ratio of a numerator and a denominator. The
    /// quorum specifies the threshold of 'Yes' votes necessary for the
    /// constitutional committee to accept a proposal procedure.
    quorum: Rational,
  }
  NewConstitution {
    /// The last governance action of type `Constitution` or
    /// `ConstitutionalCommittee`. They must all / form a chain.
    ancestor: Option<GovernanceActionId>,
    /// The new proposed constitution.
    constitution: Constitution,
  }
  NicePoll
}

pub type Vote {
  No
  Yes
  Abstain
}

pub type TransactionId =
  Hash<Blake2b_256, ByteArray>

pub type GovernanceActionId {
  transaction: TransactionId,
  proposal_procedure: Index,
}

pub type ProtocolVersion {
  major: Int,
  minor: Int,
}

pub type Constitution {
  guardrails: Option<ScriptHash>,
}

/// An epoch number after which constitutional committee member
/// mandate expires.
pub type Mandate =
  Int

pub type Voter {
  ConstitutionalCommitteeMember(Credential)
  DelegateRepresentative(Credential)
  StakePool(VerificationKeyHash)
}



================================================
FILE: lib/cardano/script_context.ak
================================================
//// This module contains utilities for manually dealing with [`ScriptContext`](#ScriptContext). This is only ever useful for writing custom `else` handlers in validators.
////
//// > [!NOTE]
//// > Unless you know what you're doing, you should prefer using named handlers:
//// >
//// > - `mint`
//// > - `spend`
//// > - `withdraw`
//// > - `publish`
//// > - `vote`
//// > - `propose`

use aiken/collection.{Index}
use cardano/address.{Credential}
use cardano/assets.{PolicyId}
use cardano/certificate.{Certificate}
use cardano/governance.{ProposalProcedure, Voter}
use cardano/transaction.{OutputReference, Redeemer, Transaction}

/// A context given to a script by the Cardano ledger when being executed.
///
/// The context contains information about the entire transaction that contains
/// the script. The transaction may also contain other scripts; to distinguish
/// between multiple scripts, the [`ScriptContext`](#ScriptContext) contains a
/// [`ScriptInfo`](#ScriptInfo) which indicates which script (or, for what
/// purpose) the transaction is being executed.
pub type ScriptContext {
  transaction: Transaction,
  redeemer: Redeemer,
  info: ScriptInfo,
}

/// Characterizes the script information. The main (and only) difference with [`ScriptPurpose`](./transaction.html#ScriptPurpose) resides in the `Spending` variant which here contains a second field `datum: Option<Data>`.
pub type ScriptInfo {
  /// For scripts executed as minting/burning policies, to insert
  /// or remove assets from circulation. It's parameterized by the identifier
  /// of the associated policy.
  Minting(PolicyId)
  /// For scripts that are used as payment credentials for addresses in
  /// transaction outputs. They govern the rule by which the output they
  /// reference can be spent.
  Spending { output: OutputReference, datum: Option<Data> }
  /// For scripts that validate reward withdrawals from a reward account.
  ///
  /// The argument identifies the target reward account.
  Withdrawing(Credential)
  /// Needed when delegating to a pool using stake credentials defined as a
  /// custom script. This purpose is also triggered when de-registering such
  /// stake credentials.
  ///
  /// The Int is a 0-based index of the given `Certificate` in `certificates`.
  Publishing { at: Index, certificate: Certificate }
  /// Voting for a type of voter using a governance action id to vote
  /// yes / no / abstain inside a transaction.
  ///
  /// The voter is who is doing the governance action.
  Voting(Voter)
  /// Used to propose a governance action.
  ///
  /// A 0-based index of the given `ProposalProcedure` in `proposal_procedures`.
  Proposing { at: Index, proposal_procedure: ProposalProcedure }
}



================================================
FILE: lib/cardano/transaction.ak
================================================
use aiken/builtin
use aiken/collection.{Index}
use aiken/collection/dict.{Dict}
use aiken/collection/list
use aiken/crypto.{
  Blake2b_256, DataHash, Hash, ScriptHash, VerificationKeyHash, blake2b_256,
}
use aiken/interval.{Interval}
use aiken/option
use cardano/address.{Address, Credential, Script, VerificationKey}
use cardano/assets.{Lovelace, PolicyId, Value}
use cardano/certificate.{Certificate}
use cardano/governance.{GovernanceActionId, ProposalProcedure, Vote, Voter}

pub type TransactionId =
  Hash<Blake2b_256, Transaction>

/// Characterizes the script purpose.
pub type ScriptPurpose {
  /// For scripts executed as minting/burning policies, to insert
  /// or remove assets from circulation. It's parameterized by the identifier
  /// of the associated policy.
  Mint(PolicyId)
  /// For scripts that are used as payment credentials for addresses in
  /// transaction outputs. They govern the rule by which the output they
  /// reference can be spent.
  Spend(OutputReference)
  /// For scripts that validate reward withdrawals from a reward account.
  ///
  /// The argument identifies the target reward account.
  Withdraw(Credential)
  /// Needed when delegating to a pool using stake credentials defined as a
  /// custom script. This purpose is also triggered when de-registering such
  /// stake credentials.
  ///
  /// The Int is a 0-based index of the given `Certificate` in `certificates`.
  Publish { at: Index, certificate: Certificate }
  /// Voting for a type of voter using a governance action id to vote
  /// yes / no / abstain inside a transaction.
  ///
  /// The voter is who is doing the governance action.
  Vote(Voter)
  /// Used to propose a governance action.
  ///
  /// A 0-based index of the given `ProposalProcedure` in `proposal_procedures`.
  Propose { at: Index, proposal_procedure: ProposalProcedure }
}

/// A Cardano `Transaction`, as seen by on-chain scripts.
///
/// Note that this is a representation of a transaction, and not the 1:1
/// translation of the transaction as seen by the ledger. In particular,
/// on-chain scripts can't see inputs locked by bootstrap addresses, outputs
/// to bootstrap addresses or just transaction metadata.
pub type Transaction {
  inputs: List<Input>,
  reference_inputs: List<Input>,
  outputs: List<Output>,
  fee: Lovelace,
  mint: Value,
  certificates: List<Certificate>,
  /// > [!IMPORTANT]
  /// > Withdrawals are ordered by ascending [Credential](./credential.html#Credential). Yet, note that [`Script`](./credential.html#Credential) credentials are treated as **lower values** than [`VerificationKey`](./credential.html#Credential) credentials.
  withdrawals: Pairs<Credential, Lovelace>,
  validity_range: ValidityRange,
  extra_signatories: List<VerificationKeyHash>,
  /// > [!IMPORTANT]
  /// > Redeemers are ordered by ascending [ScriptPurpose](./transaction.html#ScriptPurpose).
  redeemers: Pairs<ScriptPurpose, Redeemer>,
  datums: Dict<DataHash, Data>,
  id: TransactionId,
  /// > [!IMPORTANT]
  /// > Votes are ordered by ascending [Voter](./governance.html#Voter) and [GovernanceActionId](./governance.html#GovernanceActionId).<br/>First constructor variants in a type are treated as lower indices; except for [Credential](./credential.html#Credential) where [`Script`](./credential.html#Credential) credentials are treated as **lower values** than [`VerificationKey`](./credential.html#Credential) credentials.
  votes: Pairs<Voter, Pairs<GovernanceActionId, Vote>>,
  proposal_procedures: List<ProposalProcedure>,
  current_treasury_amount: Option<Lovelace>,
  treasury_donation: Option<Lovelace>,
}

/// An interval of POSIX time, measured in **number of milliseconds** since 1970-01-01T00:00:00Z.
pub type ValidityRange =
  Interval

/// An `Input` made of an output reference and, the resolved value associated with that output.
pub type Input {
  output_reference: OutputReference,
  output: Output,
}

/// An `OutputReference` is a unique reference to an output on-chain. The `output_index`
/// corresponds to the position in the output list of the transaction (identified by its id)
/// that produced that output
pub type OutputReference {
  transaction_id: Hash<Blake2b_256, Transaction>,
  output_index: Int,
}

/// A transaction `Output`, with an address, a value and optional datums and script references.
pub type Output {
  address: Address,
  value: Value,
  datum: Datum,
  reference_script: Option<ScriptHash>,
}

/// An output `Datum`.
pub type Datum {
  NoDatum
  /// A datum referenced by its hash digest.
  DatumHash(DataHash)
  /// A datum completely inlined in the output.
  InlineDatum(Data)
}

/// A type-alias for Redeemers, passed to scripts for validation. The `Data` is
/// opaque because it is user-defined and it is the script's responsibility to
/// parse it into its expected form.
pub type Redeemer =
  Data

// ## Querying

/// Find an input by its [`OutputReference`](#OutputReference). This is typically used in
/// combination with the `Spend` [`ScriptPurpose`](#ScriptPurpose) to find a script's own
/// input.
///
/// ```aiken
/// validator {
///   spend(datum, redeemer, my_output_reference, self) {
///     expect Some(input) =
///       self.inputs |> transaction.find_input(my_output_reference)
///   }
/// }
/// ```
pub fn find_input(
  inputs: List<Input>,
  output_reference: OutputReference,
) -> Option<Input> {
  inputs
    |> list.find(fn(input) { input.output_reference == output_reference })
}

/// Find the output corresponding to an output reference in a list of inputs.
/// **Fails** when no matching output is found.
///
/// ```aiken
/// validator {
///   spend(datum, redeemer, my_output_reference, self) {
///     let output =
///       self.inputs |> transaction.resolve_input(my_output_reference)
///   }
/// }
/// ```
pub fn resolve_input(
  inputs: List<Input>,
  output_reference: OutputReference,
) -> Output {
  when inputs is {
    [] -> fail
    [head, ..tail] ->
      if head.output_reference == output_reference {
        head.output
      } else {
        resolve_input(tail, output_reference)
      }
  }
}

/// Find a [`Datum`](#Datum) by its hash, if present. The function looks first for
/// datums in the witness set, and then for inline datums if it doesn't find any in
/// witnesses.
pub fn find_datum(
  outputs: List<Output>,
  datums: Dict<DataHash, Data>,
  datum_hash: DataHash,
) -> Option<Data> {
  datums
    |> dict.get(datum_hash)
    |> option.or_try(
        fn() {
          outputs
            |> list.find_map(
                fn(output) {
                  when output.datum is {
                    InlineDatum(data) ->
                      if blake2b_256(builtin.serialise_data(data)) == datum_hash {
                        Some(data)
                      } else {
                        None
                      }
                    _ -> None
                  }
                },
              )
        },
      )
}

/// Find all outputs that are paying into the given script hash, if any. This is useful for
/// contracts running over multiple transactions.
pub fn find_script_outputs(
  outputs: List<Output>,
  script_hash: ScriptHash,
) -> List<Output> {
  outputs
    |> list.filter(
        fn(output) {
          when output.address.payment_credential is {
            Script(addr_script_hash) -> script_hash == addr_script_hash
            VerificationKey(_) -> False
          }
        },
      )
}

// ## Testing

/// A placeholder / empty `Transaction` to serve as a base in a transaction
/// builder. This is particularly useful for constructing test transactions.
///
/// Every field is empty or null, and we have in particular:
///
/// ```aiken
/// use aiken/interval
///
/// transaction.placeholder.id ==
///   #"0000000000000000000000000000000000000000000000000000000000000000"
///
/// transaction.placeholder.validity_range == interval.everything
/// ```
pub const placeholder: Transaction =
  Transaction {
    inputs: [],
    reference_inputs: [],
    outputs: [],
    fee: 0,
    mint: assets.zero,
    certificates: [],
    withdrawals: [],
    validity_range: interval.everything,
    extra_signatories: [],
    redeemers: [],
    datums: dict.empty,
    id: #"0000000000000000000000000000000000000000000000000000000000000000",
    votes: [],
    proposal_procedures: [],
    current_treasury_amount: None,
    treasury_donation: None,
  }



================================================
FILE: lib/cardano/address/credential.ak
================================================
use aiken/primitive/bytearray
use cardano/address.{Credential, Script, VerificationKey}

pub fn compare(left: Credential, right: Credential) -> Ordering {
  when left is {
    Script(left) ->
      when right is {
        Script(right) -> bytearray.compare(left, right)
        _ -> Less
      }
    VerificationKey(left) ->
      when right is {
        Script(_) -> Greater
        VerificationKey(right) -> bytearray.compare(left, right)
      }
  }
}

test compare_matrix() {
  and {
    (compare(Script(""), Script("")) == Equal)?,
    (compare(VerificationKey(""), VerificationKey("")) == Equal)?,
    (compare(Script(""), VerificationKey("")) == Less)?,
    (compare(VerificationKey(""), Script("")) == Greater)?,
    (compare(Script("01"), Script("02")) == Less)?,
    (compare(Script("02"), Script("01")) == Greater)?,
    (compare(VerificationKey("01"), VerificationKey("02")) == Less)?,
    (compare(VerificationKey("02"), VerificationKey("01")) == Greater)?,
  }
}



================================================
FILE: lib/cardano/assets/strategy.ak
================================================
//// This module contains strategies used to transform [`Value`](../assets.html#Value). You can safely ignore this module if you aren't using [`flatten_with`](../assets.html#flatten_with).

use aiken/crypto.{Blake2b_224, Hash, Script}

/// A strategy for flattening an asset list.
pub type FlattenStrategy<result> =
  fn(
    Hash<Blake2b_224, Script>,
    ByteArray,
    Int,
    KeepResult<result>,
    DiscardResult<result>,
  ) ->
    List<result>

/// A callback to keep result at a given key
pub type KeepResult<result> =
  fn(result) -> List<result>

/// A callback to discard result at a given key
pub type DiscardResult<result> =
  fn() -> List<result>

// ### Flatten strategies

/// Keep all assets, combining them as a 3-tuple.
///
/// ```aiken
/// fn(policy_id, asset_name, quantity, keep, _discard) {
///   keep((policy_id, asset_name, quantity))
/// }
/// ```
pub fn triple() -> FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)> {
  fn(policy_id, asset_name, quantity, keep, _discard) {
    keep((policy_id, asset_name, quantity))
  }
}



================================================
FILE: lib/cardano/transaction/output_reference.ak
================================================
use aiken/primitive/bytearray
use aiken/primitive/int
use cardano/transaction.{OutputReference}

pub fn compare(left: OutputReference, right: OutputReference) -> Ordering {
  when bytearray.compare(left.transaction_id, right.transaction_id) is {
    Equal -> int.compare(left.output_index, right.output_index)
    ordering -> ordering
  }
}

test compare_matrix() {
  and {
    (compare(OutputReference("", 0), OutputReference("", 0)) == Equal)?,
    (compare(OutputReference("00", 42), OutputReference("00", 42)) == Equal)?,
    (compare(OutputReference("00", 0), OutputReference("01", 0)) == Less)?,
    (compare(OutputReference("01", 0), OutputReference("00", 0)) == Greater)?,
    (compare(OutputReference("00", 42), OutputReference("01", 14)) == Less)?,
    (compare(OutputReference("01", 14), OutputReference("00", 42)) == Greater)?,
    (compare(OutputReference("", 42), OutputReference("", 14)) == Greater)?,
    (compare(OutputReference("", 14), OutputReference("", 42)) == Less)?,
  }
}



================================================
FILE: lib/cardano/transaction/script_purpose.ak
================================================
use aiken/primitive/bytearray
use aiken/primitive/int
use cardano/address.{Script, VerificationKey}
use cardano/address/credential
use cardano/certificate.{RegisterCredential}
use cardano/governance.{NicePoll, ProposalProcedure, StakePool}
use cardano/governance/voter
use cardano/transaction.{
  Mint, OutputReference, Propose, Publish, ScriptPurpose, Spend, Vote, Withdraw,
}
use cardano/transaction/output_reference

pub fn compare(left: ScriptPurpose, right: ScriptPurpose) -> Ordering {
  when left is {
    Mint(left) ->
      when right is {
        Mint(right) -> bytearray.compare(left, right)
        _ -> Less
      }

    Spend(left) ->
      when right is {
        Spend(right) -> output_reference.compare(left, right)
        Mint(_) -> Greater
        _ -> Less
      }

    Withdraw(left) ->
      when right is {
        Withdraw(right) -> credential.compare(left, right)
        Spend(_) | Mint(_) -> Greater
        _ -> Less
      }

    Publish { at: left, .. } ->
      when right is {
        Publish { at: right, .. } -> int.compare(left, right)
        Spend(_) | Mint(_) | Withdraw(_) -> Greater
        _ -> Less
      }

    Vote(left) ->
      when right is {
        Vote(right) -> voter.compare(left, right)
        Propose { .. } -> Less
        _ -> Greater
      }

    Propose { at: left, .. } ->
      when right is {
        Propose { at: right, .. } -> int.compare(left, right)
        _ -> Greater
      }
  }
}

test compare_matrix() {
  let mint0 = Mint("0")
  let mint1 = Mint("1")

  let spend0 = Spend(OutputReference("", 0))
  let spend1 = Spend(OutputReference("", 1))

  let withdraw0 = Withdraw(VerificationKey("0"))
  let withdraw1 = Withdraw(VerificationKey("1"))

  let publish0 = Publish(0, RegisterCredential(Script(""), Never))
  let publish1 = Publish(1, RegisterCredential(Script(""), Never))

  let vote0 = Vote(StakePool("0"))
  let vote1 = Vote(StakePool("1"))

  let propose0 = Propose(0, ProposalProcedure(0, Script(""), NicePoll))
  let propose1 = Propose(1, ProposalProcedure(0, Script(""), NicePoll))

  and {
    (compare(mint0, mint0) == Equal)?,
    (compare(mint0, mint1) == Less)?,
    (compare(mint1, mint0) == Greater)?,
    (compare(mint0, spend0) == Less)?,
    (compare(mint0, withdraw0) == Less)?,
    (compare(mint0, publish0) == Less)?,
    (compare(mint0, vote0) == Less)?,
    (compare(mint0, propose0) == Less)?,
    (compare(spend0, spend0) == Equal)?,
    (compare(spend0, spend1) == Less)?,
    (compare(spend1, spend0) == Greater)?,
    (compare(spend0, mint0) == Greater)?,
    (compare(spend0, withdraw0) == Less)?,
    (compare(spend0, publish0) == Less)?,
    (compare(spend0, vote0) == Less)?,
    (compare(spend0, propose0) == Less)?,
    (compare(withdraw0, withdraw0) == Equal)?,
    (compare(withdraw0, withdraw1) == Less)?,
    (compare(withdraw1, withdraw0) == Greater)?,
    (compare(withdraw0, mint0) == Greater)?,
    (compare(withdraw0, spend0) == Greater)?,
    (compare(withdraw0, publish0) == Less)?,
    (compare(withdraw0, vote0) == Less)?,
    (compare(withdraw0, propose0) == Less)?,
    (compare(publish0, publish0) == Equal)?,
    (compare(publish0, publish1) == Less)?,
    (compare(publish1, publish0) == Greater)?,
    (compare(publish0, mint0) == Greater)?,
    (compare(publish0, spend0) == Greater)?,
    (compare(publish0, withdraw0) == Greater)?,
    (compare(publish0, vote0) == Less)?,
    (compare(publish0, propose0) == Less)?,
    (compare(vote0, vote0) == Equal)?,
    (compare(vote0, vote1) == Less)?,
    (compare(vote1, vote0) == Greater)?,
    (compare(vote0, mint0) == Greater)?,
    (compare(vote0, spend0) == Greater)?,
    (compare(vote0, withdraw0) == Greater)?,
    (compare(vote0, publish0) == Greater)?,
    (compare(vote0, propose0) == Less)?,
    (compare(propose0, propose0) == Equal)?,
    (compare(propose0, propose1) == Less)?,
    (compare(propose1, propose0) == Greater)?,
    (compare(propose0, mint0) == Greater)?,
    (compare(propose0, spend0) == Greater)?,
    (compare(propose0, withdraw0) == Greater)?,
    (compare(propose0, publish0) == Greater)?,
    (compare(propose0, vote0) == Greater)?,
  }
}


